ტრანზაქციები მნიშვნელოვანი ინსტრუმენტებია. ისინი გვაძლევენ საშუალებას ვთქვათ, რომ ეს მოვლენები ან ყველა ერთდროულად მოხდება, ან არცერთი. ისინი განსაკუთრებით სასარგებლოა, როცა მონაცემებს ვამატებთ მონაცემთა ბაზაში; ისინი გვაძლევენ საშუალებას ერთდროულად რამდენიმე ცხრილი განვახლოთ, იცოდეთ, რომ თუ რამე წარუმატებლად დასრულდება, ყველაფერი უკან გაიხსნება, რაც უზრუნველყოფს მონაცემების თანმიმდევრულობას.

მარტივად რომ ვთქვათ, ტრანზაქცია გვაძლევს საშუალებას შევკრათ რამდენიმე განსხვავებული აქტივობა, რომლებიც ჩვენს სისტემას ერთგან თანმიმდევრულ მდგომარეობიდან სხვაში გადაყავს ან ყველაფერი მუშაობს, ან არაფერი იცვლება.

ტრანზაქციები მხოლოდ მონაცემთა ბაზებზე არ ეხება, თუმცა ყველაზე ხშირად სწორედ იქ იყენებენ. მაგალითად, მესიჯბროკერები უკვე დიდი ხანია საშუალებას გაძლევენ ტრანზაქციებში მესიჯების გაგზავნას და მიღებას.

მონოლითური სქემის პირობებში, ჩვენი შექმნა ან განახლებები ალბათ ერთ ტრანზაქციულ საზღვრში შესრულდება. როდესაც მონაცემთა ბაზას ვყოფთ, ვკარგავთ ერთ ტრანზაქციაში არსებული უსაფრთხოების გარანტიას. განვიხილოთ მარტივი მაგალითი **MusicCorp** კონტექსტში:

შეკვეთის შექმნისას მსურს განვაახლო **order** ცხრილი, რათა ავსახო მომხმარებლის შეკვეთა, და ასევე შევქმნა ჩანაწერი საწყობისთვის, რათა მათ ჰქონდეთ ინფორმაცია შეკვეთის მოსანიშნად. ჩვენ უკვე გადავყვეთ აპლიკაციის კოდი ცალკე პაკეტებად და კლიენტის და საწყობის სქემები იმდენად შევამზადეთ, რომ მზად ვართ ისინი გადავიტანოთ საკუთარ სქემებში აპლიკაციის კოდის განცალკევებამდე.

ერთ ტრანზაქციაში მონოლითურ სქემაში შეკვეთის შექმნა და ჩანაწერის დამატება საწყობისთვის ხდება ერთ ტრანზაქციაში, როგორც ნაჩვენებია ფიგურაში 5-10.  
![[Pasted image 20250913181847.png]]
##### **ფიგურა 5-10. ორი ცხრილის განახლება ერთ ტრანზაქციაში**

მაგრამ თუ სქემა ორ ცალკე სქემად დავყოფთ ერთი კლიენტის მონაცემებისთვის, მათ შორის **order** ცხრილი, და მეორე საწყობისთვის, ვკარგავთ ტრანზაქციულ უსაფრთხოებას. შეკვეთის განთავსების პროცესი ახლა გადადის ორ ცალკე ტრანზაქციულ საზღვრზე (ფიგურა 5-11). თუ ჩანაწერი **order** ცხრილში ვერ ჩაიწერა, შეგვიძლია ყველაფერი გავაჩეროთ და დავრჩეთ თანმიმდევრულ მდგომარეობაში. მაგრამ რა მოხდება, თუ **order** ცხრილში ჩანაწერი ჩაიწერა, მაგრამ **picking** ცხრილში ვერ ჩაიწერა? 
![[Pasted image 20250913181902.png]]
##### **ფიგურა 5-11. ტრანზაქციული საზღვრების გადაცემა ერთი ოპერაციისთვის**

---

### **მეორე მცდელობის გაკეთება მოგვიანებით**  

შესაძლოა, შეკვეთა უკვე მიღებულია საკმარისი იყოს ჩვენთვის, და გადავწყვიტოთ ჩანაწერის ხელმეორედ ჩასმა საწყობის **picking** ცხრილში მოგვიანებით. ამას შეგვიძლია ვთავსოთ რიგში (queue) ან ლოგფაილში და ვცადოთ მოგვიანებით. გარკვეული ოპერაციების შემთხვევაში ეს გამართლებულია, თუმცა უნდა ვივარაუდოთ, რომ ხელმეორედ ცდა პრობლემას შეასწორებს.

მრავალი თვალსაზრისით, ეს კიდევ ერთი ფორმაა **eventual consistency**-ის. ტრანზაქციული საზღვრის გამოყენების ნაცვლად, რომ უზრუნველყოს სისტემის თანმიმდევრული მდგომარეობა ტრანზაქციის დასრულებისას, ჩვენ ვაღიარებთ, რომ სისტემა საბოლოო ჯამში ერთ-ერთი მომდევნო მომენტში მიაღწევს თანმიმდევრულ მდგომარეობას. ეს განსაკუთრებით სასარგებლოა ბიზნეს ოპერაციების შემთხვევაში, რომლებიც გრძელვადიანია.

----
### **ოპერაციის სრული გაუქმება**  

მეორე ვარიანტია მთელი ოპერაციის უარყოფა. ამ შემთხვევაში სისტემა უნდა დავაბრუნოთ თანმიმდევრულ მდგომარეობაში. **Picking** ცხრილი მარტივია ჩანაწერი ვერ ჩატარდა, მაგრამ **order** ცხრილში უკვე იყო კომიტი. საჭიროა ეს უკან დაბრუნდეს. ამისთვის უნდა გამოვიყენოთ კომპენსაციური ტრანზაქცია (compensating transaction), ანუ ახალი ტრანზაქციის დაწყება, რათა უკან მოვაბრუნოთ მომხდარი ცვლილება. მაგალითად, შეიძლება უბრალოდ გამოშვათ **DELETE** ბრძანება, რათა წაშალოთ შეკვეთა მონაცემთა ბაზიდან, და UI-ის საშუალებით აცნობოთ მომხმარებელს, რომ ოპერაცია ჩაიშალა. მონოლითურ სისტემაში აპლიკაცია შეძლებს ორივე ასპექტის მართვას, მაგრამ როცა აპლიკაციის კოდის დაყოფას ვაკეთებთ, უნდა ვიფიქროთ, სად უნდა იყოს კომპენსაციური ტრანზაქციის ლოგიკა კლიენტის სერვისში, შეკვეთის სერვისში თუ სხვაგან?

რა მოხდება, თუ კომპენსაციური ტრანზაქცია ვერ შესრულდა? შესაძლებელია. ამ შემთხვევაში, **order** ცხრილში გვექნება შეკვეთა, მაგრამ შესაბამისი **pick instruction** არ იქნება. ამ სიტუაციაში ან კომპენსაციური ტრანზაქციის ხელმეორედ ცდა გიწევთ, ან დავუშვებთ, რომ ხანდაზმული პროცესი მოგვიანებით გასწორდეს. ეს შეიძლება იყოს ადმინისტრატორის მიერ წვდომადი მენეჯმენტ ეკრანი ან ავტომატური პროცესი.

ახლა წარმოიდგინეთ, რომ არა ერთი ან ორი ოპერაცია უნდა იყოს თანმიმდევრული, არამედ სამი, ოთხი ან ხუთი. თითოეული შესაძლო წარუმატებელი ოპერაციის კომპენსაციური ტრანზაქციის მართვა ძალიან რთული ხდება აღსაქმელად და პრაქტიკაში განხორციელებისთვისაც.

----
### **გაშლილი (Distributed) ტრანზაქციები** 

კომპენსაციური ტრანზაქციების ხელით მართვის ალტერნატივა არის **გაშლილი ტრანზაქცია (distributed transaction)**. ისინი ცდილობენ ერთი ოპერაციის ფარგლებში რამდენიმე ტრანზაქციის გაერთიანებას, რომელსაც კოორდინაციას უწევს ცენტრალური პროცესი **transaction manager**. როგორც ჩვეულებრივი ტრანზაქცია, გაშლილი ტრანზაქცია ცდილობს უზრუნველყოს მონაცემთა თანმიმდევრულობა, მაგრამ ამ შემთხვევაში რამდენიმე სისტემაში, სხვადასხვა პროცესში, ხშირად ქსელის საზღვრებს შორის.

გაშლილი ტრანზაქციის მართვის ყველაზე გავრცელებული ალგორითმი **two-phase commit**. პირველი ფაზა **voting**. თითოეული მონაწილე (cohort) იტყვის transaction manager-ს, შეუძლია თუ არა მისი ტრანზაქცია განხორციელდეს. თუ ყველა მონაწილე ამბობს „კი“, transaction manager-ი უგზავნის მათ ბრძანებას commit-ის შესასრულებლად. ერთი უარყოფითი ხმა საკმარისია, რომ transaction manager-მა გააგზავნოს rollback ყველასთვის.

ეს მიდგომა მოითხოვს ყველა მხარის გაჩერებას მანამ, სანამ transaction manager-ს არ მიეცემა გაგრძელების ნებართვა. შესაბამისად, ჩვენ ვართ სენსიტიური სისტემური შეფერხების მიმართ. თუ transaction manager გაჩერდება, დარჩენილი ტრანზაქციები არასდროს დასრულდება. თუ cohort ვერ უპასუხებს voting-ის დროს, ყველაფერი ბლოკდება. ასევე არსებობს რისკი, თუ commit ვერ შესრულდება voting-ის შემდეგ. ალგორითმში არის იმპლიციტური დაშვება: cohort, რომელიც ამბობს „კი“ voting-ის პერიოდში, commit-ი უნდა შეასრულოს. Cohort-ებმა უნდა ჰქონდეთ გზა, რათა commit შესრულდეს. ამასთან, ალგორითმი ვერ არის სრულყოფილი უბრალოდ სცილდება უმეტეს შემთხვევაში შეცდომების გამოვლენას.

კოორდინაციის პროცესი ასევე იწვევს lock-ებს; ეს ნიშნავს, რომ დარჩენილი ტრანზაქციები ჩაკეტავს რესურსებს. რესურსებზე lock-ები იწვევს contention-ს, რაც მასშტაბირების პროცესი ართულებს, განსაკუთრებით გაშლილი სისტემების კონტექსტში.

გაშლილი ტრანზაქციები განხორციელებულია სპეციალური ტექნოლოგიების სტეკებისთვის, მაგალითად Java Transaction API-სთვის, რაც საშუალებას აძლევს სხვადასხვა რესურსს (მაგალითად მონაცემთა ბაზა და მესიჯ რიგი) მონაწილეობა მიიღონ ერთ ტრანზაქციაში. ალგორითმების სირთულე მაღალია, ამიტომ საკუთარი შექმნა რთულია; ამის ნაცვლად შეისწავლეთ არსებული იმპლემენტაციები.

----
## **რა გავაკეთოთ?**  

ყველა ეს გადაწყვეტილება ართულებს სისტემას. გაშლილი ტრანზაქციების მართვა რთულია და შესაძლოა მასშტაბირებაზე ზეგავლენა მოახდინოს. სისტემები, რომლებიც კომპენსაციური retry-ლოგიკის მეშვეობით საბოლოოდ თანმიმდევრულ მდგომარეობაში მოხვდებიან, რთული იქნება გააზრება და შესაძლოა სხვა კომპენსაციური ქმედებები დასჭირდეს მონაცემთა inconsistencies-ის შესასწორებლად.

როდესაც ბიზნეს ოპერაციებთან გაქვთ საქმე, რომლებიც ახლა ერთი ტრანზაქციის ფარგლებში ხდება, ჰკითხეთ საკუთარ თავს ნამდვილად აუცილებელია? შესაძლებელია, რომ სხვადასხვა ადგილობრივ ტრანზაქციებში განხორციელდეს და დაყრდნობილნი ვიყოთ **eventual consistency**-ზე? ასეთი სისტემების შექმნა და მასშტაბირება გაცილებით მარტივია.

თუ მაინც არის მდგომარეობა, რომელიც ნამდვილად უნდა იყოს თანმიმდევრული, ყველაფერი გააკეთეთ, რომ თავიდან არ დაყოფილიყოს. ძალიან იშრომეთ ამაზე. თუ ნამდვილად უნდა განხორციელდეს განახლება, გადავიდეთ ტექნიკური პროცესის ხედიდან (მაგალითად, მონაცემთა ბაზის ტრანზაქცია) და შექმენით კონკრეტული კონცეფცია, რომელიც წარმოდგენს ტრანზაქციას. ეს მოგცემთ ხელსაწყოს ან "hook"-ს კომპენსაციური ტრანზაქციების და სხვა ოპერაციების განხორციელებისთვის და საშუალებას მართოთ უფრო რთული კონცეფციები თქვენს სისტემაში.

მაგალითად, შეგიძლიათ შექმნათ **“in-process-order”**, რომელიც ბუნებრივ ადგილს წარმოადგენს შეკვეთის პროცესის მართვისთვის და გამკლავებისთვის exceptions-ებთან.