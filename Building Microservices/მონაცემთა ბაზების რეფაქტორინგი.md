წინა მაგალითებში განვიხილეთ მონაცემთა ბაზის რამდენიმე რეფაქტორინგი, რომელიც დაგეხმარებათ სქემების განცალკევებაში. უფრო დეტალური განხილვისთვის შეგიძლიათ გადახედოთ სკოტ ჯ. ემბლერისა და პრამოდ ჯ. სადალაგეს წიგნს **Refactoring Databases** (გამომცემლობა Addison-Wesley).

---

გაყოფის ეტაპობრივი განხორციელება  
ასე რომ, ჩვენ ვიპოვეთ seams ჩვენს აპლიკაციის კოდში და ისინი **bounded context-ების** გარშემო დავაჯგუფეთ. ამის საფუძველზე გამოვავლინეთ seams მონაცემთა ბაზაშიც და მაქსიმალურად ვეცადეთ მათი განცალკევება. შემდეგ რა ხდება? უნდა გავაკეთოთ ერთბაშად დიდი ცვლილება (big-bang release) — ერთიანი სერვისიდან ერთიანი სქემით პირდაპირ გადავიდეთ ორ სერვისზე, თითოეული საკუთარი სქემით?  
ჩემს რეკომენდაციას ასე ჩამოვაყალიბებდი: ჯერ სქემა გამოყავით, მაგრამ სერვისი ჯერ ისევ ერთად დატოვეთ, სანამ აპლიკაციის კოდს ცალკე მიკროსერვისებად გაყოფთ, როგორც ნაჩვენებია ფიგურაში 5-9. 
![[Pasted image 20250913181722.png]]
##### **ფიგურა 5-9. სერვისის განცალკევების ეტაპობრივი პროცესი**

ცალკე სქემის არსებობისას, ერთი მოქმედების შესასრულებლად მონაცემთა ბაზის გამოძახებების რაოდენობა შეიძლება გაიზარდოს. ადრე, შესაძლოა, ყველა საჭირო მონაცემი ერთ SELECT მოთხოვნაში მიგვეღო, ახლა კი შეიძლება მოგვიწიოს მონაცემების ორბაზიანი ამოღება და მეხსიერებაში გაერთიანება. გარდა ამისა, ორი სქემის შექმნისას ვარღვევთ ტრანზაქციულ მთლიანობას (transactional integrity), რაც ჩვენს აპლიკაციებზე მნიშვნელოვან გავლენას მოახდენს — ამაზე შემდეგ ვისაუბრებთ.

სქემების გამოყოფით, მაგრამ აპლიკაციის კოდის ერთად დატოვებით, გვექნება შესაძლებლობა საჭიროების შემთხვევაში დავაბრუნოთ ცვლილებები ან განვაგრძოთ დახვეწა ისე, რომ სერვისის მომხმარებლებს ზეგავლენა არ მოახვიოს. როგორც კი დავრწმუნდებით, რომ მონაცემთა ბაზის გაყოფას აზრი აქვს, შემდეგ შეგვეძლება ვიფიქროთ აპლიკაციის კოდის ორ დამოუკიდებელ სერვისად დაყოფაზე.