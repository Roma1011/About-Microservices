საბოლოოდ, მიკროსერვისებზე დაფუძნებული არქიტექტურის მრავალი უპირატესობა მოდის მისი გრანულარული ბუნებიდან და იმ ფაქტიდან, რომ ის გაძლევთ ბევრად მეტ არჩევანს პრობლემების გადასაჭრელად. მაგრამ ხომ შეიძლება მსგავსი დეკომპოზიციის ტექნიკებმა იმავე სარგებელს მიაღწიონ?

### გაზიარებული ბიბლიოთეკები

ძალიან სტანდარტული დეკომპოზიციის ტექნიკა, რომელიც პრაქტიკულად ყველა ენაშია ჩაშენებული, არის კოდის ბაზის დაყოფა მრავალ ბიბლიოთეკად. ეს ბიბლიოთეკები შეიძლება მოწოდებული იყოს მესამე მხარის მიერ, ან შექმნილი თქვენსავე ორგანიზაციაში.

ბიბლიოთეკები გაძლევთ შესაძლებლობას, გაზიაროთ ფუნქციონალი გუნდებსა და სერვისებს შორის. მაგალითად, შეიძლება შევქმნა სასარგებლო კოლექციის იუტილიტების ნაკრები, ან სტატისტიკის ბიბლიოთეკა, რომელიც ხელახლა გამოსაყენებელი იქნება.

გუნდებს შეუძლიათ ორგანიზდნენ ამ ბიბლიოთეკების ირგვლივ და თვითონ ბიბლიოთეკებიც ხელახლა გამოსაყენებელი ხდება. მაგრამ გარკვეული ნაკლოვანებები არსებობს.  
პირველი — თქვენ კარგავთ ნამდვილი ტექნოლოგიური ჰეტეროგენურობის შესაძლებლობას. ბიბლიოთეკა, როგორც წესი, უნდა იყოს იგივე ენაზე, ან სულ მცირე იმავე პლატფორმაზე გაშვებადი. მეორე  სისტემის ნაწილების ერთმანეთისგან დამოუკიდებლად მასშტაბირების სიმარტივე იზღუდება. შემდეგ  თუ დინამიურად დაკავშირებულ ბიბლიოთეკებს არ იყენებთ, ვერ განახლებთ ბიბლიოთეკას მთელი პროცესის ხელახალი გაშვების გარეშე, ამიტომაც თქვენი უნარი, ცალკეულ ცვლილებებს იზოლაციაში გაუშვათ, მცირდება. და ყველაზე მნიშვნელოვანი  თქვენ გაკლიათ ცხადი „შელემები“ (seams), რომლებზეც შეგიძლიათ ააგოთ არქიტექტურული დაცვის ზომები სისტემის მდგრადობის უზრუნველსაყოფად.

გაზიარებულ ბიბლიოთეკებს ნამდვილად აქვთ თავისი ადგილი. ხშირად აღმოაჩენთ, რომ ზოგადი ამოცანებისთვის ქმნით კოდს, რომელიც თქვენს ბიზნეს დომენს არ მიეკუთვნება, მაგრამ გსურთ მისი ხელახლა გამოყენება ორგანიზაციის მასშტაბით  ეს არის აშკარა კანდიდატი ხელახლა გამოსაყენებელ ბიბლიოთეკად ქცევისთვის. თუმცა ფრთხილად უნდა იყოთ. გაზიარებული კოდი, რომელიც სერვისებს შორის კომუნიკაციისთვის გამოიყენება, შეიძლება გახდეს გადაბმის (coupling) წერტილი  ამას ჩვენ 4-ე თავში განვიხილავთ.

სერვისებს შეუძლიათ და უნდა გამოიყენონ მესამე მხარის ბიბლიოთეკები აქტიურად, რათა ხელახლა გამოიყენონ საერთო კოდი. მაგრამ ეს ბოლომდე საკმარისი არ არის.

###  მოდულები

ზოგი ენა თავისივე მოდულურ დეკომპოზიციის ტექნიკას გვთავაზობს, რომელიც უბრალო ბიბლიოთეკებზე მეტად მიდის. ისინი იძლევიან მოდულების ცხოვრების ციკლის მართვის საშუალებას, ისე რომ ისინი გაშვებულ პროცესში შეიძლება ჩატვირთონ, რაც საშუალებას გაძლევთ ცვლილებები შეიტანოთ მთლიანი პროცესის გათიშვის გარეშე.

ღია კოდის ინიციატივა Open Source Gateway Initiative (OSGI) აღსანიშნავია, როგორც მოდულური დეკომპოზიციის ერთ-ერთი ტექნოლოგიურად სპეციფიკური მიდგომა. თვითონ Java-ს არ აქვს მოდულების ნამდვილი კონცეფცია და მინიმუმ Java 9-მდე მაინც მოგვიწევს ლოდინი, სანამ ეს ენაში დაემატება. OSGI, რომელიც გაჩნდა Eclipse IDE-ში პლაგინების დასაყენებლად, ახლა გამოიყენება, როგორც გზა, მოდულის კონცეფციის ბიბლიოთეკის საშუალებით ჯავაში დამატებისთვის.

OSGI-ს პრობლემა ის არის, რომ ის ცდილობს მოახვიოს ისეთი რამეები, როგორიცაა მოდულის ცხოვრების ციკლის მართვა, მაგრამ ენის შიგნით ამის საკმარისი მხარდაჭერის გარეშე. შედეგად მოდულის ავტორებს უფრო მეტი მუშაობა უწევთ იმისთვის, რომ უზრუნველყოფილ იქნას მოდულის სწორი იზოლაცია. პროცესის საზღვრებში ძალიან მარტივია ის ხაფანგიც, რომ მოდულები ზედმეტად გადაბმულები (tightly coupled) გახდნენ ერთმანეთთან, რაც უამრავ პრობლემას იწვევს. ჩემი საკუთარი გამოცდილება OSGI-სთან (რაც კოლეგების გამოცდილებასაც ემთხვევა) არის ის, რომ კარგი გუნდების შემთხვევაშიც კი ძალიან მარტივია OSGI უფრო დიდი სირთულის წყაროდ იქცეს, ვიდრე სარგებელი მოითხოვს.

Erlang განსხვავებულ მიდგომას იყენებს, სადაც მოდულები ენას და რანთაიმს ორგანულად აქვთ ჩაშენებული. ამგვარად, Erlang-ს აქვს ძალიან მოწიფული მიდგომა მოდულურ დეკომპოზიციასთან. Erlang-ის მოდულების გაჩერება, გადატვირთვა და განახლება უპრობლემოდ შეიძლება. Erlang კი ერთსა და იმავე დროს ერთ მოდულის ერთზე მეტ ვერსიასაც კი მხარს უჭერს, რაც უფრო ელეგანტურ განახლებას უზრუნველყოფს.

Erlang-ის მოდულების შესაძლებლობები ნამდვილად შთამბეჭდავია, მაგრამ თუნდაც პლატფორმას ასეთი შესაძლებლობები ჰქონდეს, ჩვენ მაინც იგივე ნაკლოვანებები გვაქვს, როგორც ჩვეულ გაზიარებულ ბიბლიოთეკებთან. მკაცრად შეზღუდული ვართ ახალი ტექნოლოგიების გამოყენების უნარში, შეზღუდული ვართ დამოუკიდებელი მასშტაბირებით, შეგვიძლია გადავუხვიოთ ზედმეტად გადაბმული ინტეგრაციის ტექნიკებისკენ და გვაკლია არქიტექტურული უსაფრთხოების „შელემები“.

არის ერთი საბოლოო დაკვირვებაც, რომლის გაზიარება ღირს: ტექნიკურად, შესაძლებელი უნდა იყოს კარგად სტრუქტურირებული, დამოუკიდებელი მოდულების შექმნა ერთ მონოლითურ პროცესში. და მაინც, ამას იშვიათად ვხედავთ. მოდულები მალე მჭიდროდ უკავშირდება დანარჩენ კოდს, რითაც ერთ-ერთ მთავარ სარგებელს თმობს. პროცესის საზღვრის არსებობა კი ამ მხრივ სისუფთავეს აიძულებს (ან მინიმუმ უფრო ართულებს არასწორი საქმის გაკეთებას!). მე არ ვიტყოდი, რომ ეს უნდა იყოს პროცესის განცალკევების მთავარი მამოძრავებელი მიზეზი, მაგრამ საინტერესოა, რომ პროცესის საზღვრებში მოდულური განცალკევების დაპირებები იშვიათად სრულდება რეალურ სამყაროში.

ამგვარად, მიუხედავად იმისა, რომ პროცესის საზღვრებში მოდულური დეკომპოზიცია შეიძლება სასურველი იყოს სისტემის სერვისებად დაყოფასთან ერთად, მხოლოდ თავისთავად ის ვერ აგვარებს ყველაფერს. თუ თქვენ „სუფთა Erlang“-ზე მომუშავე კომპანია ხართ, Erlang-ის მოდულების მაღალი ხარისხი შეიძლება ძალიან შორს წაგიყვანოთ, მაგრამ მე მგონია, რომ თქვენგან ბევრს ასეთი მდგომარეობა არ გაქვთ. დანარჩენებისთვის მოდულებზე უნდა ვიფიქროთ იგივე ტიპის სარგებლის მომტანად, რასაც გაზიარებული ბიბლიოთეკები იძლევა.