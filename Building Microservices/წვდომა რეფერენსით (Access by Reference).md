ერთ-ერთი საკითხი, რომელიც აუცილებლად უნდა აღვნიშნოთ, არის ის, **როგორ გადავცემთ ინფორმაციას ჩვენი დომენური ერთეულების შესახებ**.

მიკროსერვისმა უნდა მოიცვას მისი ძირითადი დომენური ერთეულის (მაგ. **Customer**) სრული სიცოცხლის ციკლი.  
უკვე ვისაუბრეთ, რომ **Customer-ის ცვლილების ლოგიკა უნდა ეკუთვნოდეს მხოლოდ Customer სერვისს**, და თუ გვინდა მისი შეცვლა, ეს უნდა მოხდეს შესაბამისი მოთხოვნის გაგზავნით Customer სერვისში.

აქედან გამომდინარე, Customer სერვისი უნდა განვიხილოთ როგორც **ჭეშმარიტების წყარო** (source of truth).

როცა Customer რესურსს ვიღებთ, ჩვენ ვიღებთ მის იმ მდგომარეობას, **როგორიც იყო მოთხოვნის მომენტში**.  
ამის შემდეგ კი შესაძლოა ვიღაცამ უკვე შეცვალოს ეს Customer.  
ფაქტობრივად, ჩვენ ხელთ გვაქვს მხოლოდ **მეხსიერება იმისა, თუ როგორი იყო Customer ადრე**.

რაც უფრო დიდხანს ვინახავთ ამ "მეხსიერებას", მით უფრო იზრდება შანსი, რომ ინფორმაცია მოძველდეს.  
ზოგჯერ ეს "მეხსიერება" საკმარისია, ზოგჯერ კი გვჭირდება ვიცოდეთ, შეიცვალა თუ არა მონაცემი.

 ამიტომ, როცა ერთეულის ძველი მდგომარეობა გადაგვაქვს, კარგი პრაქტიკაა **მისი რეფერენსის (მაგ., URI-ის) გადაცემაც**, რომ საჭიროებისას შევძლოთ ახალი მდგომარეობის მიღება.

**მაგალითი:**  
ვეტყვით email სერვისს, რომ გაგზავნოს წერილი, როცა შეკვეთა გაიგზავნება.  
შეგვიძლია პირდაპირ გადავცეთ კლიენტის email, სახელი, და შეკვეთის დეტალები.  
მაგრამ თუ email სერვისი ამას რიგში ალაგებს ან ქიუიდან კითხულობს, მონაცემები შეიძლება შეიცვალოს.  
ამ შემთხვევაში უკეთესია მხოლოდ **Customer-ის და Order-ის URI-ების გადაცემა**, და საჭირო მომენტში თვითონ email სერვისმა მოძებნოს ინფორმაცია.

**საპირწონე მაგალითი:**  
Event-based კოლაბორაციისას მნიშვნელოვანია ვიცოდეთ, რა **ზუსტად** მოხდა.  
თუ ვიღებთ Event-ს Customer-ის ცვლილებაზე, შეიძლება ღირებული იყოს ვიცოდეთ, როგორი იყო Customer იმ მომენტში.  
მაგრამ თუ პარალელურად გვაქვს მის URI-ზე წვდომა, შეგვიძლია როგორც ძველი, ისე ახალი მდგომარეობა დავინახოთ.

 პრობლემები და trade-off-ები:

- თუ მუდამ Customer სერვისზე მივდივართ მონაცემისთვის, ის შეიძლება ზედმეტად გადაიტვირთოს.
    
- გამოსავალია caching, როცა რესურსს თან ახლავს ინფორმაცია დროის შესახებ: **როდის იყო ეს Snapshot გადაღებული** და **რამდენ ხანს შეიძლება ჩავთვალოთ აქტიურად**.  
    HTTP ამას პირდაპირ გვთავაზობს cache-control მექანიზმებით
    
- ზოგი სერვისი Customer-ის მთელ ობიექტს არ საჭიროებს. ასეთ შემთხვევაში შეიძლება ჭკვიანური იყოს მხოლოდ აუცილებელი ველების გაგზავნა (მაგ. email service-სთვის მხოლოდ სახელი და ელფოსტა).
    

არ არსებობს მკაცრი წესი — მაგრამ **იყავით ფრთხილად**, როცა გაურკვეველია მონაცემთა სიმწიფე (freshness).