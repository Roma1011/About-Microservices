Remote Procedure Call (RPC) არის ტექნიკა, როდესაც ადგილობრივი ფუნქციის (method) გამოძახება ხდება ისე, თითქოს იგი ადგილობრივად იმპლემენტებული იყოს, მაგრამ რეალურად ფუნქცია შესრულდება გარე, დისტანციურ სერვისზე.

არსებობს სხვადასხვა ტიპის RPC ტექნოლოგია:

- ზოგი იყენებს ინტერფეისის განსაზღვრას (interface definition), მაგალითად SOAP, Thrift, Protocol Buffers. ინტერფეისის განცალკევებული განსაზღვრა ამარტივებს client და server stub-ების ავტომატურ გენერირებას სხვადასხვა ტექნოლოგიური სტეკებისთვის. მაგალითად, Java სერვერი შეიძლება expose-დეს SOAP ინტერფეისს, ხოლო .NET client-ი ავტომატურად დაიგენეროს WSDL-ის მიხედვით.
    
- სხვა ტექნოლოგიები, როგორიცაა Java RMI, მოითხოვს client-სა და server-ს შორის უფრო მჭიდრო coupling-ს — ორივე მხარე იყენებს ერთსა და იმავე underlying ტექნოლოგიას, მაგრამ არ საჭიროებს share-დ ინტერფეისის განსაზღვრას.
    

ყველა ეს ტექნოლოგია ერთ მთავარ თვისებას ავლენს: ადგილობრივი გამოძახება გამოიყურება როგორც დისტანციური.

ტექნიკური დეტალები:

- ბევრი RPC ტექნოლოგია ბინარულია (Java RMI, Thrift, Protocol Buffers), SOAP კი იყენებს XML-ს.
    
- ზოგი implementation მიბმულია კონკრეტულ ნეტვორკინგ პროტოკოლზე (მაგალითად SOAP იყენებს HTTP), ზოგს შეუძლია სხვადასხვა პროტოკოლების მხარდაჭერა, რაც დამატებით ფუნქციონალს აძლევს. მაგალითად, TCP უზრუნველყოფს delivery-ის გარანტიას, UDP არა, თუმცა უფრო მცირე overhead-ით.
    

RPC-ის უპირატესობები:

- Client და server stub-ების გენერაცია საშუალებას აძლევს ძალიან სწრაფი დასაწყისისთვის.
    
- შეგიძლია ჩვეულებრივი method call გააკეთო ისე, თითქოს ყველაფერი ადგილობრივად ხდება — მარტივი გამოყენება.
    

RPC-ის სირთულეები:

- ზოგი implementation შეიძლება თავიდან პრობლემატური არ იყოს, მაგრამ მოგვიანებით გარკვეული downsides გამოიწვიოს, რაც შესაძლოა სწრაფი დაწყების კომფორტის უპირატესობას გადააჭარბოს.


### ტექნოლოგიური coupling


ზოგიერთი RPC მექანიზმი, როგორიცაა Java RMI, ძლიერად მიბმულია კონკრეტულ პლატფორმაზე, რაც შეზღუდავს, რომელ ტექნოლოგიას შეუძლია გამოიყენოს client-სა და server-ს შორის. Thrift და Protocol Buffers აქვთ საკმაოდ ფართო მხარდაჭერა ალტერნატიული ენებისთვის, რაც ნაწილობრივ ამცირებს ამ ნაკლოვანებას, მაგრამ უნდა გაითვალისწინოთ, რომ ზოგჯერ RPC ტექნოლოგიას აქვს შეზღუდვები interoperability-ის თვალსაზრისით.

როდესაც ტექნოლოგიური coupling ხდება, ეს შეიძლება გამოიწვიოს იმისგან, რომ გამოვაჩინოთ სერვისის შიდა ტექნიკური იმპლემენტაციის დეტალები. მაგალითად, RMI-ის გამოყენება მიბმავს client-ს JVM-ზე, მაგრამ ასევე server-საც.


### ადგილობრივი გამოძახებები არ არის იგივე, რაც დისტანციური გამოძახებები

RPC-ს მთავარი იდეა არის დისტანციური გამოძახების სირთულეების დამალვა. თუმცა, ბევრი RPC იმპლემენტაცია შესაძლოა ზედმეტად ბევრს მალავდეს. ზოგი RPC ცდილობს დისტანციური method call-ები გამოიყურებოდეს ადგილობრივად, რაც მალავს მათ მთავარ განსხვავებას. ადგილობრივი გამოძახება ხშირად იწონის მცირე რესურსებს, ხოლო RPC-ში marshalling და unmarshalling პროცესი შეიძლება მნიშვნელოვანი იყოს, გარდა ნეტვორკის latency-ისა.

ამის გამო, API დიზაინის შეცნობა დისტანციური ინტერფეისებისთვის განსხვავებულად უნდა მოვიქცეთ, ვიდრე ადგილობრივი ინტერფეისებისთვის. უბრალო ადგილობრივი API-ს გადაკეთება სერვისის ბუდიად ხშირად პრობლემატურია.

ნეტვორკი არ არის საიმედო. ის შეიძლება წარუმატებლად იმუშაოს, packets შეიძლება დაზიანდეს. ამიტომ, შენ უნდა გააკეთო გათვლები სხვადასხვა ტიპის failures-ზე: შეცდომა დისტანციური სერვერისგან, ცუდი გამოძახება client-ისგან, ან ნელი პასუხი. ამ თემას უფრო დეტალურად განვიხილავთ Chapter 11-ში resiliency-ზე.


### სიმყიფე (Brittleness)

ზოგი პოპულარული RPC იმპლემენტაცია, როგორიცაა Java RMI, შეიძლება გამოიწვიოს ბრიტანელობა. მაგალითად, ვიფიქროთ ძალიან მარტივ Java ინტერფეისზე, რომელიც გაყოფილია დისტანციური API-ისთვის:

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface CustomerRemote extends Remote {
    public Customer findCustomer(String id) throws RemoteException;
    public Customer createCustomer(String firstname, String surname, String emailAddress) 
        throws RemoteException;
}

თუ გადავწყვიტეთ Customer ობიექტის შექმნა მხოლოდ email-ის გამოყენებით, უნდა დავამატოთ ახალი მეთოდი:

	public Customer createCustomer(String emailAddress) throws RemoteException;


პრობლემა ის არის, რომ ახლა უნდა განახლდეს client stub-ებიც. იმ მომხმარებლებისთვის, ვინც იყენებს ახალ მეთოდს, საჭიროა ახალი stub-ები; ზოგჯერ, specification-ის ცვლილების მიხედვით, სხვებმაც შეიძლება განაახლონ stub-ები, თუნდაც ისინი ახალ მეთოდს არ იყენებდნენ.

ასევე, ობიექტი Customer შეიძლება შეიცავდეს წარუმატებელ ზედმეტ fields-ს, მაგალითად:

public class Customer implements Serializable {
    private String firstName;
    private String surname;
    private String emailAddress;
    private String age;
}

თუ ვჩანაწერთ age field-ს, მაგრამ მომხმარებლები არასოდეს იყენებენ მას, მისი ამოღება სერვერზე გამოიწვევს შეცდომას consumer-ზეც, თუ ისინი არ განახლდნენ. ეს ნიშნავს, რომ server და client ერთდროულად უნდა განახლდეს.

RPC მექანიზმები, რომლებიც იყენებენ binary stub-ებს, იწვევს lockstep releases-ის საჭიროებას. იგივე პრობლემები წარმოიქმნება, თუ ობიექტის სტრუქტურა უნდა შეიცვალოს, მიუხედავად იმისა, რომ fields არ იშლება.

პრაქტიკაში, binary serialization-ზე დაფუძნებული ობიექტები ხშირად ინახება როგორც “expand-only” ტიპები. ეს ბრიტანელობა წარმოიქმნება, რადგან type-ები ექსპოზირებული ხდება wire-ზე, fields-ების მასა არ შეიძლება უსაფრთხოდ აიღოს, თუნდაც ზოგი აღარ გამოიყენებოდეს.

### არის RPC საშინელი?

მისი ნაკლოვანებების მიუხედავად, მე არ ვიტყოდი, რომ RPC საშინელია. ზოგიერთ გავრცელებულ იმპლემენტაციას, რაც მქონია გამოცდილება, მართლაც შეიძლება გამოიწვიოს პრობლემები, რომლებსაც აქ აღვწერე. RMI-ს გამოყენების გამოწვევების გამო, ამ ტექნოლოგიას ალბათ ძალიან შორს დავიკავებდი.

განსაკუთრებული ოპერაციები კარგად ერგება RPC მოდელს, ხოლო უფრო თანამედროვე მექანიზმები, როგორიცაა Protocol Buffers ან Thrift, ხსნიან წარსულის ზოგი “ბუნტის” პრობლემას, რადგან არ საჭიროებს client-ისა და server-ის კოდის lock-step განახლებებს.

გარდა ამისა, უნდა იცოდეთ შესაძლო შეცდომები, რომლებიც შეიძლება წარმოიშვას RPC-ის გამოყენებისას. ნუ დაიფარავთ დისტანციურ გამოძახებებს ისე, რომ ნეტვორკი სრულად დამალული იყოს, და დარწმუნდით, რომ შეგიძლიათ server-ის ინტერფეისის ევოლუცია, χωρίς lock-step განახლებების მოთხოვნა clients-ისთვის.

შეამოწმეთ, რომ client-ები ცნობიერები არიან, რომ ნეტვორკის გამოძახება მოხდება. Client libraries ხშირად გამოიყენება RPC-ის კონტექსტში და თუ არ არის სწორად სტრუქტურირებული, პრობლემებს იწვევს. ამ თემაზე მოგვიანებით უფრო დეტალურად ვისაუბრებთ.

მონაცემთა ბაზასთან ინტეგრაციასთან შედარებით, RPC აშკარად გაუმჯობესებაა request/response კოლაბორაციისთვის. თუმცა არსებობს კიდევ ერთი ვარიანტი, რომელიც უნდა განვიხილოთ.