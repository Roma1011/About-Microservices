ერიკ ევანსის წიგნი **Domain-Driven Design** (Addison-Wesley) ფოკუსირებულია იმაზე, თუ როგორ უნდა შევქმნათ სისტემები, რომლებიც რეალურ სამყაროს დომენს მოდელირებენ. ეს წიგნი სავსეა შესანიშნავი იდეებით, როგორიცაა უნივერსალური ენა (ubiquitous language), რეპოზიტორიის აბსტრაქციები და სხვა მსგავსი რამ, მაგრამ არის ერთი ძალიან მნიშვნელოვანი კონცეფცია, რომელიც თავიდან სრულიად გამომრჩა: **შეზღუდული კონტექსტი (bounded context)**.

იდეა ის არის, რომ ნებისმიერი მოცემული დომენი შედგება მრავალი შეზღუდული კონტექსტისგან, და თითოეულში არსებობენ რაღაცები (ერიკი ხშირად იყენებს სიტყვას _მოდელი_, რაც ალბათ „რაღაცებზე“ უკეთესია), რომლებიც გარეთ კომუნიკაციას არ საჭიროებენ, ისევე როგორც ის რაღაცები, რომლებიც გარე კონტექსტებთან გაზიარებულია. თითოეულ შეზღუდულ კონტექსტს აქვს **გამოკვეთილი ინტერფეისი**, სადაც ის წყვეტს, რომელი მოდელები გააზიაროს სხვა კონტექსტებთან.

შეზღუდული კონტექსტის კიდევ ერთი განმარტება, რომელიც მე მომწონს, არის:  
**„სპეციფიკური პასუხისმგებლობა, რომელიც enforced-ებულია (დამყარებულია) მკაფიო საზღვრებით.“**  
თუ გინდა ინფორმაცია შეზღუდული კონტექსტიდან, ან გინდა ფუნქციონალის მოთხოვნა მის შიგნით, კომუნიკაციას ახორციელებ მისი გამოკვეთილი საზღვრის მეშვეობით, მოდელების გამოყენებით.

თავის წიგნში ევანსი იყენებს უჯრედების ანალოგიას, სადაც „უჯრედები არსებობენ იმიტომ, რომ მათემბრანები განსაზღვრავს რა არის შიგნით და გარეთ, და რა შეიძლება გადავიდეს საზღვარზე.“

მოდით დავბრუნდეთ **MusicCorp** ბიზნესში. ჩვენი დომენი არის მთელი ბიზნესი, რომელშიც ვმუშაობთ. ის მოიცავს ყველაფერს  საწყობიდან მიმღებამდე, ფინანსებიდან შეკვეთებამდე. ჩვენ შეიძლება ეს ყველაფერი პროგრამულად არ მოვახდინოთ მოდელირება, მაგრამ ეს მაინც ის დომენია, რომელშიც ვმუშაობთ.

ვიფიქროთ იმ დომენის ნაწილებზე, რომლებიც ჰგავს ევანსის მიერ აღწერილ შეზღუდულ კონტექსტებს. **MusicCorp-ში** საწყობი არის საქმიანობის კერა შეკვეთების მართვა რომლებიც იგზავნება (და იშვიათი დაბრუნებებიც), ახალი მარაგის მიღება, ავტოსატვირთოებით რბოლა და ასე შემდეგ. სხვაგან, ფინანსების დეპარტამენტი ალბათ ნაკლებად მხიარულია, მაგრამ მაინც ძალიან მნიშვნელოვან ფუნქციას ასრულებს ჩვენს ორგანიზაციაში. ეს თანამშრომლები მართავენ ხელფასებს, აწარმოებენ კომპანიის ანგარიშებს და ამზადებენ მნიშვნელოვან ანგარიშებს. ბევრ ანგარიშს. ალბათ მაგიდაზე საინტერესო სათამაშოებიც აქვთ.

### გაზიარებული და დამალული მოდელები (Shared and Hidden Models)

**MusicCorp-ის** შემთხვევაში, შეგვიძლია ფინანსური დეპარტამენტი და საწყობი განვიხილოთ როგორც ორი ცალკეული **შეზღუდული კონტექსტი**. ორივეს აქვს **გამოკვეთილი ინტერფეისი** გარე სამყაროსთან (მაგალითად მარაგის ანგარიშები, ხელფასის ფურცლები და ა.შ.), და ორივეს აქვს ისეთი დეტალები, რომლებიც მხოლოდ მათთვისაა საჭირო (საწყობისთვის  სათავსოები, ამწე მანქანები; ფინანსებისთვის  კალკულატორები).

ფინანსურ დეპარტამენტს არ სჭირდება იცოდეს საწყობის შიდა დეტალები. მაგრამ გარკვეული ინფორმაცია მაინც სჭირდება  მაგალითად, მარაგის დონეების შესახებ, რათა ბუღალტერია იყოს განახლებული. **ფიგურა 3-1** ასახავს კონტექსტის დიაგრამის მაგალითს. ვხედავთ ისეთ ცნებებს, რომლებიც საწყობისთვისაა შიდა, მაგალითად **Picker** (ადამიანი, რომელიც შეკვეთებს აგროვებს), თაროები, რომლებიც მარაგის მდებარეობას წარმოადგენენ და ა.შ. ანალოგიურად, კომპანიის **ზოგადი საექსპერტო ბუღალტრული წიგნი** (general ledger) ფუნდამენტურია ფინანსებისთვის, მაგრამ აქ გარე სამყაროსთვის არ არის გაზიარებული.
![[Pasted image 20250907222033.png]]
#### ფიგურა 3-1.

თუმცა, კომპანიის ღირებულების დასათვლელად ფინანსურ თანამშრომლებს სჭირდებათ ინფორმაცია მარაგის შესახებ. აქედან გამომდინარე, **საწყობში არსებული ნივთი (stock item)** ხდება **გაზიარებული მოდელი** ორ კონტექსტს შორის. მაგრამ უნდა აღვნიშნოთ, რომ არ არის საჭირო მარაგის ნივთის შესახებ ყველა დეტალის უშეცდომოდ გარე სამყაროსთვის გადაცემა. მაგალითად, მიუხედავად იმისა, რომ შიდა სისტემაში ვაფიქსირებთ თუ რომელი თაროს ან ზონის ქვეშ უნდა იყოს ეს მარაგის ნივთი, ეს დეტალი გაზიარებულ მოდელში საჭირო არ არის. აქ გვაქვს **შიდა წარმოდგენა** და **გარე წარმოდგენა**, რომელსაც ვუზიარებთ სხვებს. ბევრი თვალსაზრისით, ეს წინასწარ გვამზადებს REST-ის გარშემო მყოფი დისკუსიისთვის.

ხშირად შეიძლება შევხვდეთ მოდელებს, რომლებსაც ერთი და იგივე სახელი აქვთ, მაგრამ სრულიად განსხვავებული მნიშვნელობა სხვადასხვა კონტექსტში. მაგალითად, შეიძლება გვქონდეს ცნება **დაბრუნება (return)**, რაც ნიშნავს, რომ მომხმარებელი რაღაც ნივთს აბრუნებს. **მომხმარებლის კონტექსტში** დაბრუნება ნიშნავს სასაქონლო ეტიკეტის დაბეჭდვას, პაკეტის გაგზავნას და ანაზღაურების მოლოდინს. **საწყობისთვის** კი ეს წარმოადგენს პაკეტს, რომელიც მალე მოვა და მარაგში დასაბრუნებელ ნივთს. შესაბამისად, საწყობში ვამატებთ დამატებით ინფორმაციას დაბრუნებაზე, რომელიც დაკავშირებულია შესასრულებელ ამოცანებთან; მაგალითად, შეიძლება შევქმნათ **restock მოთხოვნა**.

ასე რომ, დაბრუნების გაზიარებული მოდელი ხდება დაკავშირებული განსხვავებულ პროცესებთან და დამხმარე ობიექტებთან თითოეულ შეზღუდულ კონტექსტში, მაგრამ ეს მაინც მთლიანად **შიდა საზრუნავია** თითოეული კონტექსტისთვის.


### მოდულები და სერვისები

თუ ჩვენ მკაფიოდ დავფიქრდებით, რომელი მოდელები უნდა გავაზიაროთ და არ გავაზიარებთ შიდა წარმოდგენებს, ავირიდებთ ერთ-ერთ შესაძლო ხაფანგს, რომელიც მჭიდრო გადაბმას (tight coupling) იწვევს ანუ იმას, რაც არ გვინდა. ასევე ვპოულობთ საზღვარს ჩვენს დომენში, სადაც მსგავსი ბიზნეს შესაძლებლობები ერთად უნდა არსებობდეს, რითიც ვაღწევთ მაღალ კოჰეზიას (high cohesion).  
ამგვარად, **შეზღუდული კონტექსტები** შესანიშნავად გამოდგება კომპოზიციური საზღვრების დასადგენად.

როგორც პირველი თავში განვიხილეთ, ჩვენ გვაქვს შესაძლებლობა, ერთსა და იმავე პროცესის ფარგლებში გამოვიყენოთ მოდულები, რათა კოდი, რომელიც ერთმანეთთან არის დაკავშირებული, ერთად შევინახოთ და შევამციროთ გადაბმა სისტემის სხვა მოდულებთან. როცა ახალ კოდბაზას იწყებთ, ეს ალბათ კარგი ადგილია დასაწყებად. ამიტომ, როგორც კი თქვენს დომენში იპოვით შეზღუდულ კონტექსტებს, დარწმუნდით, რომ ისინი კოდბაზაში **მოდულების სახით არის მოდელირებული**, გაზიარებული და დამალული მოდელებით.

ეს მოდულური საზღვრები შემდეგ შესანიშნავი კანდიდატები ხდებიან მიკროსერვისებისთვის. ზოგადად, მიკროსერვისები მკაფიოდ უნდა თანხვდებოდეს შეზღუდულ კონტექსტებს. როცა საკმარისად გამოცდილი გახდებით, შეიძლება გადაწყვიტოთ იმ ნაბიჯის გამოტოვება, როდესაც შეზღუდულ კონტექსტს ჯერ მონოლითურ სისტემაში მოდულად მოიაზრებთ, და პირდაპირ ცალკე სერვისად გადახვიდეთ. თუმცა, დასაწყისში, ჯობს სისტემა მეტად **მონოლითური მხარისკენ გადაიხაროს**; სერვისების საზღვრების არასწორად განსაზღვრა ძვირი ჯდება, ამიტომ გონივრულია დაველოდოთ სტაბილიზაციას, სანამ ახალ დომენს გავეცნობით. 

ამგვარად, თუ ჩვენი სერვისის საზღვრები თანხვდება დომენის შეზღუდულ კონტექსტებს და ჩვენი მიკროსერვისები წარმოადგენს ამ კონტექსტებს, ჩვენ შესანიშნავ საწყისს ვიღებთ იმისთვის, რომ ჩვენი მიკროსერვისები იყოს **თვითდამოკიდებული (loosely coupled)** და **მაღალი კოჰეზიის მქონე (highly cohesive)**.


### ნაადრევი დეკომპოზიცია

**ThoughtWorks-ში** ჩვენ თვითონ შევეჯახეთ მიკროსერვისებად ძალიან სწრაფად დაყოფის გამოწვევებს. კონსულტაციების გარდა, ჩვენ რამდენიმე პროდუქტსაც ვქმნით. ერთ-ერთი იყო **SnapCI**, ჰოსტინგზე დაფუძნებული უწყვეტი ინტეგრაციისა (Continuous Integration) და უწყვეტი მიწოდების (Continuous Delivery) ხელსაწყო გუნდს მანამდე გამოცდილება ჰქონდა მსგავს ინსტრუმენტზე **Go-CD**, ღია კოდის მქონე უწყვეტი მიწოდების ხელსაწყოზე, რომელიც ლოკალურად დიპლოითდებოდა და არა ღრუბელში.

მიუხედავად იმისა, რომ თავდაპირველად **SnapCI-ს** და **Go-CD-ს** შორის გარკვეული კოდის გაზიარება არსებობდა, საბოლოოდ **SnapCI** სრულიად ახალი კოდბაზა აღმოჩნდა. თუმცა, გუნდის წინა გამოცდილებამ **CD tooling-ის** დომენში გაბედული გახადა  სწრაფად გამოეყოთ საზღვრები და სისტემა მიკროსერვისების ნაკრებად აეგოთ.

რამდენიმე თვის შემდეგ აშკარა გახდა, რომ **SnapCI-ს** გამოყენების შემთხვევები ოდნავ განსხვავდებოდა, რის გამოც სერვისების საზღვრები სწორად არ იყო განსაზღვრული. შედეგად, მრავალი ცვლილება უნდა განხორციელებულიყო სხვადასხვა სერვისში ერთდროულად, რამაც ცვლილებების მაღალი ღირებულება გამოიწვია. საბოლოოდ გუნდმა სერვისები კვლავ **ერთ მონოლითურ სისტემად შეაერთა**, რათა უკეთ გაეგოთ, სად უნდა არსებულიყო საზღვრები. ერთი წლის შემდეგ კი გუნდმა შეძლო მონოლითის გაყოფა მიკროსერვისებად, რომელთა საზღვრები უკვე გაცილებით უფრო სტაბილური აღმოჩნდა.

ეს შორს არის ერთადერთი მაგალითისგან. სისტემის ნაადრევი დეკომპოზიცია მიკროსერვისებად ძვირი შეიძლება დაჯდეს, განსაკუთრებით თუ დომენისთვის ახალი ხართ. 

ბევრი თვალსაზრისით, არსებული კოდბაზის დაყოფა მიკროსერვისებად ბევრად უფრო მარტივია, ვიდრე თავიდანვე მიკროსერვისებით დაწყება.