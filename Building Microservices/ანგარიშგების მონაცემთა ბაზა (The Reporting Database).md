ანგარიშგებას, ჩვეულებრივ, სჭირდება მონაცემების გაერთიანება ორგანიზაციის სხვადასხვა ნაწილიდან, რათა წარმოადგინოს სასარგებლო შედეგი. მაგალითად, შეიძლება გვინდოდეს ჩვენი **general ledger** მონაცემების გამდიდრება იმით, თუ რა იყო გაყიდული, რასაც მივიღებთ კატალოგიდან. ან შეიძლება გვინდა შევისწავლოთ კონკრეტული, მაღალი ღირებულების მომხმარებლების შოპინგის ქცევა, რაც საჭიროებს ინფორმაციას მათ შეძენების ისტორიასა და მომხმარებლის პროფილზე.

სტანდარტულ, მონოლითურ სერვის არქიტექტურაში, ყველა მონაცემი ერთ დიდ მონაცემთა ბაზაში ინახება. ეს ნიშნავს, რომ ყველა მონაცემი ერთ ადგილასაა, ამიტომ ანგარიშგება ყველა ინფორმაციის ფარგლებში შედარებით მარტივია, რადგან მონაცემებს SQL კითხვებით ან მსგავსად მარტივად შეგვიძლია გაერთიანება.

ტიპიურად, ჩვენ არ ვატარებთ ანგარიშგების კითხვებს ძირითად მონაცემთა ბაზაზე, რადგან კითხვების მიერ გამოწვეული დატვირთვა გავლენას მოახდენს სისტემის შესრულებაზე. ამიტომ ხშირად ანგარიშგების სისტემა ჩადგმულია **read replica**-ზე, როგორც ნაჩვენებია ფიგურაში 5-12. 
![[Pasted image 20250913182408.png]]
**ფიგურა 5-12. სტანდარტული read replication**

ამ მიდგომის უდიდესი დადებითი მხარე ისაა, რომ ყველა მონაცემი ერთ ადგილასაა, ამიტომ შეგვიძლია შედარებით მარტივი ინსტრუმენტებით დავაყენოთ კითხვები. მაგრამ არსებობს რამდენიმე ნაკლი:

1. მონაცემთა ბაზის სქემა ახლა ფაქტობრივად ხდება **მონოლითური სერვისების და ნებისმიერ ანგარიშგების სისტემას შორის გაზიარებული API**. შესაბამისად, სქემის ცვლილება ყურადღებით უნდა მართოთ. რეალობაში, ეს დამატებითი დაბრკოლებაა, რომელიც ბევრს აშინებს ასეთ ცვლილებაზე პასუხისმგებლობის აღებისგან.
    
2. გვაქვს შეზღუდული არჩევანი, თუ როგორ შეიძლება მონაცემთა ბაზა ოპტიმიზირებული იყოს ნებისმიერი გამოყენებისთვის ან აქტიური სისტემისთვის, ან ანგარიშგებისთვის. ზოგი მონაცემთა ბაზა საშუალებას გვაძლევს read replica-ზე ოპტიმიზაციები შევასრულოთ, რაც ანგარიშგების გაწერას უფრო სწრაფს და ეფექტურს ხდის; მაგალითად, **MySQL**-ი საშუალებას გვაძლევს ავაშენოთ სხვა ბექენდი, რომელიც არ იტვირთება ტრანზაქციების მართვით. თუმცა, მონაცემთა სტრუქტურის ცვლილება ანგარიშგების გასაუმჯობესებლად შეუძლებელია, თუ ეს უარყოფითად აისახება აქტიურ სისტემაზე.
    

ხშირად ხდება, რომ სქემა ან ერთ საქმეს აძლევს კარგ მხარდაჭერას და მეორეს ვერაფერს, ან ხდება ყველაზე დაბალი საერთო გამოთვლა (lowest common denominator), რაც არც ერთ მიზანს არ ერგება.

შეიძლება ეს კიდევ უფრო გართულდეს, რადგან ჩვენთვის ხელმისაწვდომი მონაცემთა ბაზის ვარიანტები ბოლო დროს გამრავლდა. სტანდარტული რელაციური მონაცემთა ბაზები SQL ინტერფეისებს აწვდიან, რაც ბევრ ანგარიშგების ინსტრუმენტთან მუშაობს, მაგრამ ყოველთვის საუკეთესო არჩევანი არ არის აქტიური სერვისების მონაცემების შენახვისთვის. მაგალითად, რა მოხდება, თუ ჩვენი აპლიკაციის მონაცემები უკეთ არის მოდელირებული **გრაფის სახით**, როგორც Neo4j-ში? ან თუ გვინდა **დოკუმენტური მონაცემთა ბაზა** გამოიყენოთ, როგორიცაა MongoDB? ან შესაძლოა, ჩვენ გვინდოდეს **სვეტ-ორენტირებული მონაცემთა ბაზა**, როგორიცაა Cassandra, რაც დიდ მოცულობებზე მასშტაბირებას ძალიან ამარტივებს?

ერთ მონაცემთა ბაზაში ორივე მიზნისთვის გაჩერება ხშირად გვიწევს ამ არჩევანის შეზღუდვას და ახალი შესაძლებლობების გამოსაცდელად შანსის გარეშე რჩება.

ასე რომ, იდეალური არაა, მაგრამ მუშაობს (მთავარია). ახლა წარმოიდგინეთ, რომ ჩვენი ინფორმაცია მრავალ სხვადასხვა სისტემაშია შენახული რა ვქნათ? შესაძლებელია თუ არა ყველა მონაცემის გაერთიანება ანგარიშგების შესასრულებლად? შესაძლებელია თუ არა სტანდარტული ანგარიშგების მონაცემთა ბაზის მოდელთან დაკავშირებული გარკვეული უარყოფითი მხარეების მინიმიზაცია?

გარკვეულად, არსებობს რამდენიმე ვალიდური ალტერნატივა ამ მიდგომისთვის. რომელი გადაწყვეტილება იქნება ყველაზე შესაფერისი, დამოკიდებულია რამდენიმე ფაქტორზე, მაგრამ შევისწავლით რამდენიმე პრაქტიკულ ვარიანტს, რაც ჩემთვის ცნობილია.