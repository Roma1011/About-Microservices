ყველა შეხვედრაზე, სადაც მიკროსერვისებზე ვსაუბრობ, მაკითხავენ ერთსა და იმავე კითხვას:  
**როგორ ვაკეთებთ ვერსიონირებას?**

ეს ძალიან მართებული შიშია  ადრე თუ გვიან მოგვიწევს სერვისის ინტერფეისის შეცვლა.

### მაქსიმალურად გადადეთ (Defer it)

ყველაზე კარგი გზა **breaking change-ის ზემოქმედების შესამცირებლად** არის **მისი თავიდან აცილება**.

- სწორი ინტეგრაციის ტექნოლოგიის არჩევა ამაში დიდ როლს თამაშობს.
    
    - **Database integration** ართულებს ცვლილებების მართვას.
        
    - **REST** უფრო მოქნილია  შიდა იმპლემენტაციის ცვლილება ხშირად ინტერფეისს არ ეხება.
        
- მეორე გზაა კლიენტებში კარგი ქცევის წახალისება და თავიდან აცილება იმისა, რომ ისინი ზედმეტად მჭიდროდ მიბმულნი იყვნენ სერვისზე.
**მაგალითი:**  
Email სერვისს ვთხოვთ: „გაგზავნე Order shipped შეტყობინება Customer ID=1234-ზე“.  
ის ეძებს Customer-ს და იღებს ასეთ პასუხს (მაგ. 4-3):

	<customer>
	  <firstname>Sam</firstname>
	  <lastname>Newman</lastname>
	  <email>sam@magpiebrain.com</email>
	  <telephoneNumber>555-1234-5678</telephoneNumber>
	</customer>
მაგალითი 4-3

Email სერვისს რეალურად სჭირდება მხოლოდ: **firstname, lastname, email**.  
მაგრამ binding ტექნოლოგიები (განსაკუთრებით strongly typed ენებში) ხშირად ცდილობენ **ყველა ველის** ბაინდინგს.

თუ მოვიშორებთ `telephoneNumber` ველს, **კლიენტები შეიძლება მოულოდნელად გაფუჭდნენ**.

ასევე, თუ Customer ობიექტი უფრო სტრუქტურირებული გახდება (მაგ. 4-4):

	<customer>
	  <naming>
	    <firstname>Sam</firstname>
	    <lastname>Newman</lastname>
	    <nickname>Magpiebrain</nickname>
	    <fullname>Sam "Magpiebrain" Newman</fullname>
	  </naming>
	  <email>sam@magpiebrain.com</email>
	</customer>
მაგალითი 4-4

ჩვენი საჭირო ველები (`firstname`, `lastname`) ისევ აქ არის, მაგრამ სხვა გზით.  
თუ კლიენტის კოდი **ზედმეტად მკაცრია**, ის გაფუჭდება.

გამოსავალია **Tolerant Reader** (Martin Fowler):

- წაკითხვისას ავიღოთ მხოლოდ ის, რაც გვჭირდება.
    
- დანარჩენი ცვლილებები უგულებელვყოთ.
    

ეს ასახავს **Postel’s Law**-ს („იყავი კონსერვატიული შენს ქმედებაში, მაგრამ ლიბერალური იმაში, რასაც სხვებისგან იღებ“).

ჩვენს კონტექსტში:

- სერვისის **კლიენტმა** უნდა სცადოს იყოს მაქსიმალურად მოქნილი.
    
- სერვისის **ავტორმა** კი  მაქსიმალურად ფრთხილი ცვლილებებისას.

### ცვლილებების ადრეული აღმოჩენა


ძალიან მნიშვნელოვანია, რომ ჩვენ მოვახერხოთ იმ ცვლილებების დროულად აღმოჩენა, რომლებიც მომხმარებლებს გაუტეხს მუშაობას, რადგანაც—even თუ საუკეთესო ტექნოლოგიას ავარჩევთ—გატეხვები მაინც შეიძლება მოხდეს. მე ძალიან strongly მხარს ვუჭერ **consumer-driven contracts**-ს, რომელზეც সপ্তავე თავში ვისაუბრებთ, რათა ეს პრობლემები რაც შეიძლება ადრე გამოჩნდეს. თუ თქვენ მხარს უჭერთ მრავალ განსხვავებულ კლიენტურ ბიბლიოთეკას, მაშინ თითოეულ მათგანზე ტესტების გაშვებაც ეფექტური ტექნიკაა. როგორც კი მიხვდებით, რომ გატეხვა გარდაუვალია, თქვენ გაქვთ არჩევანი: ან სცადოთ თავიდან აიცილოთ altogether, ან მიიღოთ იგი და დაიწყოთ სწორი კომუნიკაცია იმ ადამიანებთან, ვინც მომხმარებელ სერვისებს უძღვება.


#### სემანტიკური ვერსიები

რა კარგი იქნებოდა, რომ კლიენტს მხოლოდ სერვისის ვერსიის ნომერზე დაკვირვებით გაეგო, შეეძლო თუ არა მასთან ინტეგრაცია? სწორედ ამას იძლევა **სემანტიკური ვერსიების** სპეციფიკაცია. სემანტიკურ ვერსიაში თითოეული ნომერი ფორმატშია:  
**MAJOR.MINOR.PATCH**.

- **MAJOR**-ის გაზრდა ნიშნავს უკუ-თავსებადობასთან შეუთავსებელ ცვლილებებს.
    
- **MINOR**-ის გაზრდა ნიშნავს ახალი ფუნქციონალის დამატებას, რომელიც უკუ-თავსებადია.
    
- **PATCH**-ის გაზრდა მიუთითებს შეცდომების გამოსწორებაზე არსებულ ფუნქციონალში.
    

ვთქვათ, ჩვენი Helpdesk აპლიკაცია აგებულია **customer service-ის 1.2.0 ვერსიაზე**. თუ დაემატა ახალი შესაძლებლობა და customer service გახდა **1.3.0**, ჩვენი Helpdesk აპლიკაციას ქცევაში არაფერი ეცვლება და არ უნდა მოველოდეთ ცვლილებების საჭიროებას. თუმცა ვერ დავრწმუნდებით, რომ ის იმუშავებს customer service-ის **1.1.0 ვერსიასთან**, რადგან შესაძლოა მას ეყრდნობოდეს 1.2.0-ში დამატებულ ფუნქციონალს. ასევე უნდა მოველოდოთ ცვლილებების შეტანას ჩვენს აპლიკაციაში, თუ გამოვა **2.0.0** ვერსია.

თქვენ შეგიძლიათ გადაწყვიტოთ გქონდეთ სემანტიკური ვერსია მთლიანი სერვისისთვის ან თუნდაც ინდივიდუალური endpoint-ებისთვის, თუ ისინი ერთდროულად არსებობენ (როგორც მომდევნო სექციაშია აღწერილი).

ეს ვერსიირების სქემა გვაძლევს საშუალებას მხოლოდ სამ ნომერში ჩავსვათ დიდი მოცულობის ინფორმაცია და მოლოდინები. სრული სპეციფიკაცია ძალიან მარტივად განმარტავს, რა მოლოდინი უნდა ჰქონდეს კლიენტს თითოეული ციფრის ცვლილებაზე, და ამით ამარტივებს კომუნიკაციას, უნდა მოახდინოს თუ არა ცვლილებამ გავლენა მომხმარებლებზე. სამწუხაროდ, გადანაწილებულ სისტემებში ეს მიდგომა ჯერ კიდევ საკმაოდ იშვიათად გამოიყენება.

### განსხვავებული Endpoint-ების თანაარსებობა

თუ ყველაფერი გავაკეთეთ იმისათვის, რომ თავიდან აგვეცილებინა interface-ის გატეხილი ცვლილება, შემდეგი ნაბიჯი მისი ზემოქმედების შეზღუდვაა. რასაც აუცილებლად უნდა ავიცილოთ, არის ის, რომ მომხმარებლები იძულებული გახდნენ ჩვენსავე ტემპში განახლდნენ, რადგან ყოველთვის გვინდა შევინარჩუნოთ მიკროსერვისების დამოუკიდებელი გამოშვების შესაძლებლობა.

ერთი მიდგომა, რომელიც წარმატებით გამომიყენებია, არის **ძველი და ახალი ინტერფეისების თანაარსებობა ერთსა და იმავე სერვისში**. ანუ თუ გვინდა გამოვუშვათ გატეხილი ცვლილება, ჩვენ ვუშვებთ სერვისის ახალ ვერსიას, რომელიც ერთდროულად აჩვენებს როგორც ძველ, ისე ახალ endpoint-ს.

ეს გვაძლევს საშუალებას რაც შეიძლება სწრაფად გამოვუშვათ ახალი მიკროსერვისი და ინტერფეისი, მაგრამ ამავე დროს მივცეთ მომხმარებლებს დრო გადასასვლელად. როგორც კი ყველა მომხმარებელი შეწყვეტს ძველი endpoint-ის გამოყენებას, მასთან ერთად შეგვიძლია მისი კოდი მთლიანად ამოვიღოთ (როგორც ნაჩვენებია 4-5 ფიგურაში).

![[Pasted image 20250908233616.png]]
##### ფიგურა 4-5

როდესაც ბოლოს გამოვიყენე ეს მიდგომა, იმდენად ბევრი მომხმარებელი გვყავდა და იმდენი გატეხილი ცვლილება შევიტანეთ, რომ endpoint-ის სამ სხვადასხვა ვერსიას ვამყოფებდით ერთად. ეს ნამდვილად არ არის სასურველი! მთელი ამ კოდის შენახვა და ტესტირება, რომ ყველაფერი ისევ მუშაობდეს, სერიოზულ დამატებით ტვირთს ქმნიდა. ამის მართვა რომ გაგვიადვილებინა, ყველა მოთხოვნას V1 endpoint-იდან ვაქცევდით V2 მოთხოვნად, ხოლო შემდეგ V2-ს ვაქცევდით V3-ად. ამ გზით ძალიან მკაფიოდ ჩანდებოდა, რომელი კოდი წავიდოდა endpoint-ების გაქრობასთან ერთად.

ფაქტობრივად, ეს არის **expand and contract** ნიმუში: ჯერ ვაფართოებთ შესაძლებლობებს და ვუჭერთ მხარს როგორც ძველ, ისე ახალ გზებს. ხოლო როცა ძველი მომხმარებლები ახალ გზაზე გადავლენ, ვკუმშავთ API-ს და ვშლით ძველ ფუნქციონალს.

თუ endpoint-ების თანაარსებას აპირებთ, თქვენ გჭირდებათ მექანიზმი, რომლითაც დამრეკავები სწორად გადაამისამართებენ თავიანთ მოთხოვნებს. HTTP-ზე დაფუძნებულ სისტემებში მე მინახავს ორივე მიდგომა: ვერსიის ნომერი მოთხოვნის ჰედერში, ან პირდაპირ URI-ში — მაგალითად, `/v1/customer/` ან `/v2/customer/`. არ ვიცი, რომელი უფრო სწორი გზაა. ერთი მხრივ, მინდა URI იყოს netransparent-ი, რათა მომხმარებლები არ მიბმულიყვნენ URI-შაბლონებზე, მაგრამ მეორე მხრივ, URI-ში ვერსიის შეტანა უფრო თვალსაჩინო და მოთხოვნების რაუტინგს ამარტივებს.

RPC-ს შემთხვევაში საქმე უფრო რთულდება. მე ამას ვუმკლავდებოდი protocol buffers-ით ისე, რომ მეთოდები სხვადასხვა namespace-ში მქონდა — მაგალითად, `v1.createCustomer` და `v2.createCustomer`. მაგრამ თუ ცდილობ ერთდროულად სხვადასხვა ვერსიის ერთსა და იმავე ტიპების მხარდაჭერას, ეს შეიძლება ძალიან მტკივნეული გახდეს.

### ერთდროულად რამდენიმე სერვისის ვერსიის გამოყენება

ვერსიირების კიდევ ერთი ხსენებული გადაწყვეტაა, რომ ერთდროულად იყოს გაშვებული სერვისის სხვადასხვა ვერსია და ძველი მომხმარებლები თავიანთ ტრეფიკს გადაამისამართებენ ძველ ვერსიაზე, ახალი მომხმარებლები კი — ახალზე (როგორც ნაჩვენებია 4-6 ფიგურაში). ამ მიდგომას Netflix იშვიათად იყენებს იმ შემთხვევებში, როცა ძველი მომხმარებლების შეცვლის ღირებულება ძალიან მაღალია, განსაკუთრებით იმ იშვიათ სიტუაციებში, როცა ლეგასი მოწყობილობები ისევ მიბმულია ძველ API ვერსიებზე. პირადად მე ამ იდეის გულშემატკივარი არ ვარ და მესმის, რატომაც იყენებს Netflix მას იშვიათად.
![[Pasted image 20250908233840.png]]
#### ფიგურა 4-6

პირველ რიგში, თუ მე სერვისში შიდა ბაგის გამოსწორება დამჭირდება, უკვე ორ განსხვავებულ სერვისზე მომიწევს ფიქსი და გამოშვება. ეს ალბათ იმას ნიშნავს, რომ სერვისის კოდბაზის დაჩästვა მომიწევს, რაც ყოველთვის პრობლემურია. მეორე მხრივ, საჭირო ხდება სიბრძნე იმისათვის, რომ მომხმარებლები სწორ მიკროსერვისს მივმართოთ. ეს ქცევა გარდაუვლად ხვდება სადღაც შუამავალში ან nginx-ის სკრიპტების გროვაში, რაც სისტემის ქცევის გააზრებას ართულებს.

ბოლოს, გავითვალისწინოთ ნებისმიერი პერმანენტული მდგომარეობა, რასაც ჩვენი სერვისი მართავს. მომხმარებლები, რომლებიც შეიქმნება სერვისის ნებისმიერი ვერსიით, უნდა შეინახოს და გახდეს ხილული ყველა სერვისისთვის, მიუხედავად იმისა, რომელი ვერსიით შეიქმნა თავდაპირველად. ეს შეიძლება გახდეს დამატებითი სირთულის წყარო.

**ფიგურა 4-6.** ერთი და იმავე სერვისის რამდენიმე ვერსიის გაშვება ძველი endpoint-ების მხარდასაჭერად

მრავალჯერადი ერთდროული სერვისის ვერსიების თანაარსებობა მოკლე პერიოდით სრულად გამართლებულია, განსაკუთრებით ისეთ შემთხვევებში, როგორიცაა **blue/green deployment-ები** ან **canary release-ები** (ამ ნიმუშებზე დეტალურად ვისაუბრებთ সপ্তავე თავში). ასეთ სიტუაციებში ჩვენ შეიძლება მხოლოდ რამდენიმე წუთით ან საათით ვამყოფებდეთ თანაარსებულ ვერსიებს და, როგორც წესი, ერთდროულად მხოლოდ ორი განსხვავებული ვერსია იქნება.

რაც უფრო დიდხანს გრძელდება მომხმარებლების ახალ ვერსიაზე გადაყვანა და გამოშვება, მით უფრო უნდა იფიქროთ endpoint-ების თანაარსებობაზე ერთსა და იმავე მიკროსერვისში, ვიდრე სრულიად განსხვავებული ვერსიების თანაარსებაზე. მე კვლავაც სკეპტიკურად ვუყურებ ამ მიდგომას და არ მჯერა, რომ ეს საშუალო პროექტისთვის ღირსეული ძალისხმევაა.