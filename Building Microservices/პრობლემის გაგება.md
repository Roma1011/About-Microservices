პირველი ნაბიჯი არის კოდის განხილვა, რათა დავინახოთ, რომელი ნაწილები წააკითხავენ ან ჩაწერენ მონაცემებს ბაზაში.

- გავრცელებული პრაქტიკა: **repository layer**, რომელზეც დამყარებულია, მაგალითად, Hibernate, რომელიც მარტივად აკავშირებს კოდს ბაზასთან და ასოცირებს ობიექტებს ან მონაცემთა სტრუქტურებს.
    
- თუ კოდის პაკეტებად დაყოფა უკვე შესრულდა **bounded contexts-ის მიხედვით**, იგივე უნდა გავაკეთოთ **database access code-ისთვის**.
    
- ეს შეიძლება მოითხოვოს repository layer-ის რამდენიმე ნაწილად გაყოფა, როგორც ნაჩვენებია ფიგურაში 5-1.

![[Pasted image 20250909163229.png]]
##### ფიგურა 5-1 საცავების დაყოფა

---

### მონაცემთა ბაზის ქოლოკაცია

ბაზასთან დაკავშირებული კოდი შესაბამის კონტექსტში ყოფნა დაგვეხმარება გავიგოთ, რომელი მონაცემები გამოიყენება კონკრეტული კოდის ნაწილის მიერ.

- Hibernate, მაგალითად, ძალიან თვალსაჩინოდ აჩვენებს, თუ თითო bounded context-ისთვის ცალკეული mapping file გამოიყენება.
    

მაგრამ ეს არ გვაძლევს სრულ სურათს:

- შეიძლება ვნახოთ, რომ **finance code** იყენებს ledger ცხრილს, **catalog code** იყენებს line item ცხრილს,
    
- მაგრამ შეიძლება უცნობი იყოს, რომ ბაზა ფარავს **foreign key** დამოკიდებულებას ledger-დან line item ცხრილზე.
    

ამ ტიპის **database-level constraints**-ს გამოსავლენად საჭიროა დამატებითი ხელსაწყო, მაგალითად **SchemaSpy**, რომელიც გრაფიკულად აჩვენებს ცხრილების ურთიერთდამოკიდებულებას.

---

### ჩახლართული ცხრილების გათავისუფლება

ეს პროცესი გეხმარებათ გაიგოთ დამოკიდებულება ცხრილებს შორის, რომლებიც საბოლოოდ შეიძლება გახდნენ სერვისების საზღვარი.

- პრობლემა: ერთსა და იმავე ცხრილებს იყენებენ სხვადასხვა **bounded contexts**-ი.
    
- ეს გამოწვევები რთულია, მაგრამ მოსაგვარებელია.
    

---

### MusicCorp-ის მაგალითი

- გვაქვს ოთხი **bounded context** და გვინდა ისინი შევცვალოთ ოთხ **სერვისად**, რომლებიც თანამშრომლობენ.
    
- განვიხილავთ კონკრეტულ პრობლემებს და შესაძლო გადაწყვეტილებებს.
    
- მიუხედავად იმისა, რომ მაგალითები რელაციური ბაზებისთვისაა, მსგავსი პრობლემები გვხვდება **NOSQL** ბაზებშიც.


### მაგალითი: უცხო გასაღების (Foreign Key) ურთიერთობის გაწყვეტა  


ამ მაგალითში, ჩვენი კატალოგის კოდი იყენებს ზოგად **line item** ცხრილს ალბომის შესახებ ინფორმაციის შესანახად. ჩვენი ფინანსური კოდი იყენებს **ledger** ცხრილს ფინანსური ტრანზაქციების დასაფიქსირებლად. ყოველი თვის ბოლოს გვჭირდება ანგარიშების გენერირება ორგანიზაციის სხვადასხვა ადამიანებისთვის, რათა მათ ნახონ, როგორ მივიწევთ წინ. გვინდა, რომ ეს ანგარიშები ლამაზად და ადვილად წასაკითხად გამოიყურებოდეს. ამიტომ, იმის ნაცვლად, რომ simply ვთქვათ: „ჩვენ გავყიდეთ SKU 12345-ის 400 ეგზემპლარი და გამოვიმუშავეთ $1,300“, გვსურს დავამატოთ მეტი ინფორმაცია გაყიდულ პროდუქტზე (ანუ: „ჩვენ გავყიდეთ ბრიუს სპრინგსტინის _Greatest Hits_-ის 400 ეგზემპლარი და გამოვიმუშავეთ $1,300“). ამისათვის, ჩვენი ანგარიშგების კოდი ფინანსურ პაკეტში შედის **line item** ცხრილში, რათა ამოიღოს შესაბამისი SKU-ს სათაური. შესაძლოა არსებობდეს ასევე უცხო გასაღების შეზღუდვა (**foreign key constraint**) **ledger** ცხრილიდან **line item** ცხრილზე, როგორც ეს ნაჩვენებია ფიგურაში 5-2.
![[Pasted image 20250913175658.png]]
##### ფიგურა 5-2. უცხო გასაღების ურთიერთობა

ახლა როგორ მოვაგვაროთ ეს? საჭიროა ცვლილება ორ ადგილას. პირველ რიგში, უნდა შევწყვიტოთ ფინანსური კოდის პირდაპირი წვდომა **line item** ცხრილზე, რადგან ეს ცხრილი რეალურად ეკუთვნის კატალოგის კოდს და არ გვინდა, რომ მონაცემთა ბაზის ინტეგრაცია ხდებოდეს მაშინ, როცა კატალოგი და ფინანსები უკვე დამოუკიდებელი სერვისები იქნებიან. ყველაზე სწრაფი გამოსავალია ის, რომ ფინანსურმა კოდმა აღარ შეაღწიოს **line item** ცხრილში, არამედ კატალოგის პაკეტში გამოვყოთ API ზარი, რომელსაც ფინანსური კოდი გამოიძახებს. ეს API ზარი გახდება წინამორბედი იმ ზარისა, რომელსაც მომავალში ქსელზე გავაკეთებთ, როგორც ნაჩვენებია ფიგურაში 5-3.
![[Pasted image 20250913175734.png]]
##### **ფიგურა 5-3. უცხო გასაღების ურთიერთობის მოხსნის შემდეგ**

ამ ეტაპზე ცხადი ხდება, რომ შესაძლოა ანგარიშის გენერირებისას მოგვიწიოს ორი ცალკე მონაცემთა ბაზის გამოძახება. ეს ნორმალურია. იგივე მოხდება მაშინაც, თუ ეს ორი ცალკე სერვისია. ჩვეულებრივ ასეთ დროს წარმოშობს შეკითხვებს წარმადობის (performance) შესახებ. ჩემს პასუხს მარტივად ვიტყვი: რამდენად სწრაფი უნდა იყოს თქვენი სისტემა? და ახლა რამდენად სწრაფია? თუ შეგიძლიათ გააზომოთ მიმდინარე წარმადობა და იცით, როგორი სიჩქარეა მისაღები, მაშინ შეგიძლიათ დარწმუნებული იყოთ ცვლილების სწორობაში. ხანდახან ერთი ოპერაციის შენელება სხვა უპირატესობების სანაცვლოდ სწორია მით უმეტეს, თუ ეს „შენელებული“ მაინც სრულებით მისაღებია.


ხოლო უცხო გასაღების ურთიერთობაზე რა ვქნათ? ამას მთლიანად ვკარგავთ. ეს შეზღუდვა უნდა ვმართოთ უკვე მიღებულ სერვისებში და არა მონაცემთა ბაზის დონეზე. ეს შეიძლება ნიშნავდეს, რომ თავად მოგვიწევს სერვისებს შორის თანმიმდევრულობის (consistency) შემოწმების იმპლემენტაცია, ან დავააქტიუროთ მოქმედებები დაკავშირებული მონაცემების გასაწმენდად. ეს საჭიროა თუ არა — ხშირად ტექნოლოგის გადასაწყვეტი არ არის. მაგალითად, თუ ჩვენი შეკვეთის (order) სერვისი შეიცავს კატალოგის ელემენტების ID-ების სიას, რა მოხდება, თუ კატალოგის ელემენტი წაიშლება და შეკვეთა ახლა მიუთითებს არასწორ კატალოგის ID-ზე? დავუშვათ? თუ დავუშვებთ, მაშინ როგორ უნდა გამოისახოს ეს შეკვეთაში ჩვენებისას? თუ არ დავუშვებთ, როგორ შევამოწმოთ, რომ ეს დარღვევა არ ხდება? ასეთ კითხვებზე პასუხი უნდა მიიღოთ იმ ადამიანებისგან, რომლებიც განსაზღვრავენ, როგორ უნდა მოიქცეს თქვენი სისტემა მომხმარებლებისთვის.