პირველი ნაბიჯი არის კოდის განხილვა, რათა დავინახოთ, რომელი ნაწილები წააკითხავენ ან ჩაწერენ მონაცემებს ბაზაში.

- გავრცელებული პრაქტიკა: **repository layer**, რომელზეც დამყარებულია, მაგალითად, Hibernate, რომელიც მარტივად აკავშირებს კოდს ბაზასთან და ასოცირებს ობიექტებს ან მონაცემთა სტრუქტურებს.
    
- თუ კოდის პაკეტებად დაყოფა უკვე შესრულდა **bounded contexts-ის მიხედვით**, იგივე უნდა გავაკეთოთ **database access code-ისთვის**.
    
- ეს შეიძლება მოითხოვოს repository layer-ის რამდენიმე ნაწილად გაყოფა, როგორც ნაჩვენებია ფიგურაში 5-1.

![[Pasted image 20250909163229.png]]
##### ფიგურა 5-1 საცავების დაყოფა

---

### მონაცემთა ბაზის ქოლოკაცია

ბაზასთან დაკავშირებული კოდი შესაბამის კონტექსტში ყოფნა დაგვეხმარება გავიგოთ, რომელი მონაცემები გამოიყენება კონკრეტული კოდის ნაწილის მიერ.

- Hibernate, მაგალითად, ძალიან თვალსაჩინოდ აჩვენებს, თუ თითო bounded context-ისთვის ცალკეული mapping file გამოიყენება.
    

მაგრამ ეს არ გვაძლევს სრულ სურათს:

- შეიძლება ვნახოთ, რომ **finance code** იყენებს ledger ცხრილს, **catalog code** იყენებს line item ცხრილს,
    
- მაგრამ შეიძლება უცნობი იყოს, რომ ბაზა ფარავს **foreign key** დამოკიდებულებას ledger-დან line item ცხრილზე.
    

ამ ტიპის **database-level constraints**-ს გამოსავლენად საჭიროა დამატებითი ხელსაწყო, მაგალითად **SchemaSpy**, რომელიც გრაფიკულად აჩვენებს ცხრილების ურთიერთდამოკიდებულებას.

---

### ჩახლართული ცხრილების გათავისუფლება

ეს პროცესი გეხმარებათ გაიგოთ დამოკიდებულება ცხრილებს შორის, რომლებიც საბოლოოდ შეიძლება გახდნენ სერვისების საზღვარი.

- პრობლემა: ერთსა და იმავე ცხრილებს იყენებენ სხვადასხვა **bounded contexts**-ი.
    
- ეს გამოწვევები რთულია, მაგრამ მოსაგვარებელია.
    

---

### MusicCorp-ის მაგალითი

- გვაქვს ოთხი **bounded context** და გვინდა ისინი შევცვალოთ ოთხ **სერვისად**, რომლებიც თანამშრომლობენ.
    
- განვიხილავთ კონკრეტულ პრობლემებს და შესაძლო გადაწყვეტილებებს.
    
- მიუხედავად იმისა, რომ მაგალითები რელაციური ბაზებისთვისაა, მსგავსი პრობლემები გვხვდება **NOSQL** ბაზებშიც.


### მაგალითი: უცხო გასაღების (Foreign Key) ურთიერთობის გაწყვეტა  


ამ მაგალითში, ჩვენი კატალოგის კოდი იყენებს ზოგად **line item** ცხრილს ალბომის შესახებ ინფორმაციის შესანახად. ჩვენი ფინანსური კოდი იყენებს **ledger** ცხრილს ფინანსური ტრანზაქციების დასაფიქსირებლად. ყოველი თვის ბოლოს გვჭირდება ანგარიშების გენერირება ორგანიზაციის სხვადასხვა ადამიანებისთვის, რათა მათ ნახონ, როგორ მივიწევთ წინ. გვინდა, რომ ეს ანგარიშები ლამაზად და ადვილად წასაკითხად გამოიყურებოდეს. ამიტომ, იმის ნაცვლად, რომ simply ვთქვათ: „ჩვენ გავყიდეთ SKU 12345-ის 400 ეგზემპლარი და გამოვიმუშავეთ $1,300“, გვსურს დავამატოთ მეტი ინფორმაცია გაყიდულ პროდუქტზე (ანუ: „ჩვენ გავყიდეთ ბრიუს სპრინგსტინის _Greatest Hits_-ის 400 ეგზემპლარი და გამოვიმუშავეთ $1,300“). ამისათვის, ჩვენი ანგარიშგების კოდი ფინანსურ პაკეტში შედის **line item** ცხრილში, რათა ამოიღოს შესაბამისი SKU-ს სათაური. შესაძლოა არსებობდეს ასევე უცხო გასაღების შეზღუდვა (**foreign key constraint**) **ledger** ცხრილიდან **line item** ცხრილზე, როგორც ეს ნაჩვენებია ფიგურაში 5-2.
![[Pasted image 20250913175658.png]]
##### ფიგურა 5-2. უცხო გასაღების ურთიერთობა

ახლა როგორ მოვაგვაროთ ეს? საჭიროა ცვლილება ორ ადგილას. პირველ რიგში, უნდა შევწყვიტოთ ფინანსური კოდის პირდაპირი წვდომა **line item** ცხრილზე, რადგან ეს ცხრილი რეალურად ეკუთვნის კატალოგის კოდს და არ გვინდა, რომ მონაცემთა ბაზის ინტეგრაცია ხდებოდეს მაშინ, როცა კატალოგი და ფინანსები უკვე დამოუკიდებელი სერვისები იქნებიან. ყველაზე სწრაფი გამოსავალია ის, რომ ფინანსურმა კოდმა აღარ შეაღწიოს **line item** ცხრილში, არამედ კატალოგის პაკეტში გამოვყოთ API ზარი, რომელსაც ფინანსური კოდი გამოიძახებს. ეს API ზარი გახდება წინამორბედი იმ ზარისა, რომელსაც მომავალში ქსელზე გავაკეთებთ, როგორც ნაჩვენებია ფიგურაში 5-3.
![[Pasted image 20250913175734.png]]
##### **ფიგურა 5-3. უცხო გასაღების ურთიერთობის მოხსნის შემდეგ**

ამ ეტაპზე ცხადი ხდება, რომ შესაძლოა ანგარიშის გენერირებისას მოგვიწიოს ორი ცალკე მონაცემთა ბაზის გამოძახება. ეს ნორმალურია. იგივე მოხდება მაშინაც, თუ ეს ორი ცალკე სერვისია. ჩვეულებრივ ასეთ დროს წარმოშობს შეკითხვებს წარმადობის (performance) შესახებ. ჩემს პასუხს მარტივად ვიტყვი: რამდენად სწრაფი უნდა იყოს თქვენი სისტემა? და ახლა რამდენად სწრაფია? თუ შეგიძლიათ გააზომოთ მიმდინარე წარმადობა და იცით, როგორი სიჩქარეა მისაღები, მაშინ შეგიძლიათ დარწმუნებული იყოთ ცვლილების სწორობაში. ხანდახან ერთი ოპერაციის შენელება სხვა უპირატესობების სანაცვლოდ სწორია მით უმეტეს, თუ ეს „შენელებული“ მაინც სრულებით მისაღებია.


ხოლო უცხო გასაღების ურთიერთობაზე რა ვქნათ? ამას მთლიანად ვკარგავთ. ეს შეზღუდვა უნდა ვმართოთ უკვე მიღებულ სერვისებში და არა მონაცემთა ბაზის დონეზე. ეს შეიძლება ნიშნავდეს, რომ თავად მოგვიწევს სერვისებს შორის თანმიმდევრულობის (consistency) შემოწმების იმპლემენტაცია, ან დავააქტიუროთ მოქმედებები დაკავშირებული მონაცემების გასაწმენდად. ეს საჭიროა თუ არა — ხშირად ტექნოლოგის გადასაწყვეტი არ არის. მაგალითად, თუ ჩვენი შეკვეთის (order) სერვისი შეიცავს კატალოგის ელემენტების ID-ების სიას, რა მოხდება, თუ კატალოგის ელემენტი წაიშლება და შეკვეთა ახლა მიუთითებს არასწორ კატალოგის ID-ზე? დავუშვათ? თუ დავუშვებთ, მაშინ როგორ უნდა გამოისახოს ეს შეკვეთაში ჩვენებისას? თუ არ დავუშვებთ, როგორ შევამოწმოთ, რომ ეს დარღვევა არ ხდება? ასეთ კითხვებზე პასუხი უნდა მიიღოთ იმ ადამიანებისგან, რომლებიც განსაზღვრავენ, როგორ უნდა მოიქცეს თქვენი სისტემა მომხმარებლებისთვის.


---

### მაგალითი: გაზიარებული სტატიკური მონაცემები  

მე იმდენივე ქვეყნის კოდი მინახავს მონაცემთა ბაზებში შენახული (როგორც ნაჩვენებია ფიგურაში 5-4), რამდენიც **StringUtils** კლასები დამიწერია შიდა Java პროექტებისთვის. ეს თითქოს იმაზე მიანიშნებს, რომ ჩვენ ვგეგმავთ სისტემის მიერ მხარდაჭერილი ქვეყნების ცვლილებას ბევრად უფრო ხშირად, ვიდრე ახალი კოდის დეპლოის ვაკეთებთ. მაგრამ, რაც არ უნდა იყოს ნამდვილი მიზეზი, ასეთი გაზიარებული სტატიკური მონაცემების მონაცემთა ბაზაში შენახვის მაგალითები ხშირად გვხვდება. მაშინ რა ვქნათ ჩვენს მუსიკის მაღაზიაში, თუ ყველა პოტენციური სერვისი ერთსა და იმავე ცხრილიდან კითხულობს მსგავსად?  
![[Pasted image 20250913181323.png]]
##### **ფიგურა 5-4. ქვეყნის კოდები მონაცემთა ბაზაში**


ჩვენ რამდენიმე ვარიანტი გვაქვს.  
პირველი ვარიანტია ამ ცხრილის დუბლირება თითოეული პაკეტისთვის, გრძელვადიანი ხედვით, რომ ის საბოლოოდ თითოეულ სერვისშიც დუბლირებული იქნება. რა თქმა უნდა, ეს იწვევს თანმიმდევრულობის პრობლემის პოტენციალს: რა მოხდება, თუ ერთ ცხრილს განვაახლებ, რათა ავსახო ავსტრალიის აღმოსავლეთ სანაპიროსთან ახალი სახელმწიფოს — **Newmantopia** — შექმნა, ხოლო მეორე ცხრილი არ განახლდება?

მეორე ვარიანტია ამ გაზიარებული, სტატიკური მონაცემების კოდად განხილვა. შესაძლოა ეს იყოს property ფაილში, რომელიც სერვისის ნაწილად დეპლოიშია, ან უბრალოდ ენუმერაციის (enumeration) სახით. მონაცემთა თანმიმდევრულობის პრობლემა კვლავ რჩება, თუმცა გამოცდილებამ აჩვენა, რომ კონფიგურაციის ფაილების განახლება გაცილებით უფრო მარტივია, ვიდრე მოქმედი მონაცემთა ბაზის ცხრილების შეცვლა. ეს ხშირად ძალიან გონივრული მიდგომაა.

მესამე ვარიანტი, რომელიც შეიძლება ზედმეტად რადიკალური იყოს, არის ამ სტატიკური მონაცემების ცალკე სერვისში გადატანა. ორ შემთხვევას შევხვედრივარ, სადაც სტატიკური საცნობარო მონაცემების მოცულობა, სირთულე და წესები იმდენად მნიშვნელოვანი იყო, რომ ეს მიდგომა გამართლებული აღმოჩნდა, მაგრამ თუ მხოლოდ ქვეყნის კოდებზე ვსაუბრობთ, ალბათ ზედმეტია.

პირადად მე, უმეტეს სიტუაციაში ვცდილობ ეს მონაცემები კონფიგურაციის ფაილებში ან პირდაპირ კოდში დავტოვო, რადგან ეს უმეტეს შემთხვევაში ყველაზე მარტივი გამოსავალია.

---
### მაგალითი: გაზიარებული მონაცემები  

ახლა გადავიდეთ უფრო რთულ, მაგრამ საკმაოდ გავრცელებულ პრობლემაზე, რომელიც ჩნდება მაშინ, როცა ცდილობთ სისტემების განცალკევებას: გაზიარებული **ცვლადი** მონაცემები. ჩვენი ფინანსური კოდი თვალს ადევნებს მომხმარებლების მიერ მათი შეკვეთებისთვის შესრულებულ გადახდებს და ასევე აღრიცხავს დაბრუნებისას მათთვის გაცემულ ანაზღაურებებს. იმავდროულად, საწყობის კოდი ამახვილებს ჩანაწერებს, რათა აჩვენოს, რომ მომხმარებლის შეკვეთები გაგზავნილია ან მიღებულია. ეს ყველაფერი ნაჩვენებია ერთ მოსახერხებელ ადგილას ვებსაიტზე, რათა მომხმარებლებმა ნახონ, რა ხდება მათ ანგარიშზე. სიმარტივისთვის, ეს ინფორმაცია fairly generic **customer record** ცხრილში გვაქვს შენახული, როგორც ნაჩვენებია ფიგურაში 5-5.  
![[Pasted image 20250913181433.png]]
##### **ფიგურა 5-5. მომხმარებლის მონაცემებზე წვდომა: ხომ არ გვაკლია რამე?**

ამრიგად, როგორც ფინანსური, ისე საწყობის კოდი წერს (და ალბათ ხანდახან კითხულობს კიდეც) ერთსა და იმავე ცხრილში. როგორ გამოვყოთ ეს ერთმანეთისგან? რეალურად აქ გვაქვს ის, რასაც ხშირად შეხვდებით — დომენის კონცეფცია, რომელიც კოდში არ არის მოდელირებული და ფაქტობრივად არაოფიციალურადაა გამოხატული მონაცემთა ბაზაში. აქ დაკარგული დომენის კონცეფციაა **მომხმარებელი (Customer)**.

ჩვენ უნდა ვაქციოთ მომხმარებლის ეს ამჟამინდელი აბსტრაქტული კონცეფცია კონკრეტულად განსაზღვრულად. გარდამავალ ეტაპზე ვქმნით ახალ პაკეტს სახელად **Customer**. შემდეგ შეგვიძლია გამოვყოთ API, რომლითაც **Customer** კოდი ხელმისაწვდომი იქნება სხვა პაკეტებისთვის, მაგალითად ფინანსებისთვის ან საწყობისთვის. საბოლოო ეტაპზე შეიძლება მივიღოთ დამოუკიდებელი **customer service**, როგორც ნაჩვენებია ფიგურაში 5-6.  
![[Pasted image 20250913181453.png]]
##### **ფიგურა 5-6. მომხმარებლის bounded context-ის ამოცნობა**

---

### მაგალითი: გაზიარებული ცხრილები  

ფიგურა 5-7 გვიჩვენებს ჩვენს ბოლო მაგალითს. ჩვენს კატალოგს სჭირდება იმ ჩანაწერების სახელისა და ფასის შენახვა, რომლებსაც ვყიდით, ხოლო საწყობს სჭირდება ინვენტარის ელექტრონული აღრიცხვის წარმოება. გადავწყვიტეთ, ეს ორი რამ ერთსა და იმავე ადგილას generic **line item** ცხრილში შეგვენახა. ადრე, როცა ყველა კოდი ერთმანეთში იყო შერწყმული, არ ჩანდა, რომ რეალურად განსხვავებულ საზრუნავებს ვურევდით, მაგრამ ახლა უკვე ნათელია, რომ აქ ორი განსხვავებული კონცეფციაა, რომელიც ცალ-ცალკე შეიძლება შეინახოს. 
![[Pasted image 20250913181555.png]]
##### **ფიგურა 5-7. ცხრილები, რომლებიც სხვადასხვა კონტექსტს შორისაა გაზიარებული**

გამოსავალია ცხრილის ორად გაყოფა, როგორც ნაჩვენებია ფიგურაში 5-8 — მაგალითად, საწყობისთვის **stock list** ცხრილის შექმნა და კატალოგის დეტალებისთვის **catalog entry** ცხრილის შექმნა. 
![[Pasted image 20250913181602.png]]
##### **ფიგურა 5-8. გაზიარებული ცხრილის განცალკევება**