პირველი ნაბიჯი არის კოდის განხილვა, რათა დავინახოთ, რომელი ნაწილები წააკითხავენ ან ჩაწერენ მონაცემებს ბაზაში.

- გავრცელებული პრაქტიკა: **repository layer**, რომელზეც დამყარებულია, მაგალითად, Hibernate, რომელიც მარტივად აბმენს კოდს ბაზასთან და ასოცირებს ობიექტებს ან მონაცემთა სტრუქტურებს.
    
- თუ კოდის პაკეტებად დაყოფა უკვე შესრულდა **bounded contexts-ის მიხედვით**, იგივე უნდა გავაკეთოთ **database access code-ისთვის**.
    
- ეს შეიძლება მოითხოვოს repository layer-ის რამდენიმე ნაწილად გაყოფა, როგორც ნაჩვენებია ფიგურაში 5-1.

![[Pasted image 20250909163229.png]]
##### ფიგურა 5-1 საცავების დაყოფა

---

### მონაცემთა ბაზის ქოლოკაცია

ბაზასთან დაკავშირებული კოდი შესაბამის კონტექსტში ყოფნა დაგვეხმარება გავიგოთ, რომელი მონაცემები გამოიყენება კონკრეტული კოდის ნაწილის მიერ.

- Hibernate, მაგალითად, ძალიან თვალსაჩინოდ აჩვენებს, თუ თითო bounded context-ისთვის ცალკეული mapping file გამოიყენება.
    

მაგრამ ეს არ გვაძლევს სრულ სურათს:

- შეიძლება ვნახოთ, რომ **finance code** იყენებს ledger ცხრილს, **catalog code** იყენებს line item ცხრილს,
    
- მაგრამ შეიძლება უცნობი იყოს, რომ ბაზა ფარავს **foreign key** დამოკიდებულებას ledger-დან line item ცხრილზე.
    

ამ ტიპის **database-level constraints**-ს გამოსავლენად საჭიროა დამატებითი ხელსაწყო, მაგალითად **SchemaSpy**, რომელიც გრაფიკულად აჩვენებს ცხრილების ურთიერთდამოკიდებულებას.

---

### ჩახლართული ცხრილების გათავისუფლება

ეს პროცესი გეხმარებათ გაიგოთ დამოკიდებულება ცხრილებს შორის, რომლებიც საბოლოოდ შეიძლება გახდნენ სერვისების საზღვარი.

- პრობლემა: ერთსა და იმავე ცხრილებს იყენებენ სხვადასხვა **bounded contexts**-ი.
    
- ეს გამოწვევები რთულია, მაგრამ მოსაგვარებელია.
    

---

### MusicCorp-ის მაგალითი

- გვაქვს ოთხი **bounded context** და გვინდა ისინი შევცვალოთ ოთხ **სერვისად**, რომლებიც თანამშრომლობენ.
    
- განვიხილავთ კონკრეტულ პრობლემებს და შესაძლო გადაწყვეტილებებს.
    
- მიუხედავად იმისა, რომ მაგალითები რელაციური ბაზებისთვისაა, მსგავსი პრობლემები გვხვდება **NOSQL** ბაზებშიც.