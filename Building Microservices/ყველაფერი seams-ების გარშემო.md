თავი 3-ში ვისაუბრეთ იმაზე, რომ ჩვენი სერვისები უნდა იყვნენ **მაღალად კოეზიურები** და **ჩამოკიდებულებებით თავისუფალები**. პრობლემა მონოლითთან ის არის, რომ ხშირად ის სწორედ საპირისპიროა:

- კოეზიურობა აქ ნაკლებად არსებობს — კოდი, რომელიც ერთად უნდა იცვლებოდეს, არ არის შეკრული, პირიქით, ერთმანეთისგან უსარგებლო ნაწილები ჩასმულია ერთად.
    
- თავისუფალი ჩაკავშირება ფაქტიურად არ არსებობს — ცვლილების შეტანა კონკრეტულ ხაზზე შეიძლება ადვილად გაკეთდეს, მაგრამ მისი განთავსება მონოლითის სხვა ნაწილებსაც შეიძლება აისახოს, საბოლოოდ კი მთელი სისტემა უნდა განახლდეს.
    

**Michael Feathers**-მა, წიგნში _Working Effectively with Legacy Code_, განსაზღვრა **seam** — კოდის ის ნაწილი, რომელსაც შეგვიძლია ცალკე მოვექცეთ და ვიმუშაოთ ისე, რომ კოდის სხვა ნაწილზე გავლენა არ მოახდინოს. ჩვენც უნდა ვიპოვოთ **seams**, მაგრამ არა მხოლოდ კოდის გასაწმენდად — არამედ იმისთვის, რომ **სერვისის საზღვრებად** გამოვიყენოთ ისინი.

#### კარგი seam-ის მახასიათებლები

როგორც უკვე ვისაუბრეთ, **bounded contexts** შესანიშნავი seams-ებია, რადგან ისინი ბუნებით **კოეზიურიც არიან და თავისუფალ ჩაკავშირებადაც**. ამიტომ პირველი ნაბიჯია ამ საზღვრების იდენტიფიცირება ჩვენს კოდში.

მრავალი პროგრამირების ენა გვთავაზობს **namespace**-ების კონცეფციას, რაც საშუალებას გვაძლევს მსგავსი კოდი ერთ ადგილას დავყოთ. მაგალითად, Java-ს **package** კონცეფცია ამის მცირე მაგალითია. სხვა ძირითადი ენებიც აქვთ მსგავსი კონცეფცია, JavaScript-ი აქ შეიძლება გამონაკლისად ჩაითვალოს.