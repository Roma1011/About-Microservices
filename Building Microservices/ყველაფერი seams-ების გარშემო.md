[[თავი 3. როგორ დავმოდელოთ სერვისები]] ვისაუბრეთ იმაზე, რომ ჩვენი სერვისები უნდა იყვნენ **მაღალად კოეზიურები** და **ჩამოკიდებულებებით თავისუფალები**. პრობლემა მონოლითთან ის არის, რომ ხშირად ის სწორედ საპირისპიროა:

- კოეზიურობა აქ ნაკლებად არსებობს  კოდი, რომელიც ერთად უნდა იცვლებოდეს, არ არის შეკრული, პირიქით, ერთმანეთისგან უსარგებლო ნაწილები ჩასმულია ერთად.
    
- თავისუფალი ჩაკავშირება ფაქტიურად არ არსებობს  ცვლილების შეტანა კონკრეტულ ხაზზე შეიძლება ადვილად გაკეთდეს, მაგრამ მისი განთავსება მონოლითის სხვა ნაწილებსაც შეიძლება აისახოს, საბოლოოდ კი მთელი სისტემა უნდა განახლდეს.
    

**Michael Feathers**-მა, წიგნში _Working Effectively with Legacy Code_, განსაზღვრა **seam** — კოდის ის ნაწილი, რომელსაც შეგვიძლია ცალკე მოვექცეთ და ვიმუშაოთ ისე, რომ კოდის სხვა ნაწილზე გავლენა არ მოახდინოს. ჩვენც უნდა ვიპოვოთ **seams**, მაგრამ არა მხოლოდ კოდის გასაწმენდად არამედ იმისთვის, რომ **სერვისის საზღვრებად** გამოვიყენოთ ისინი.

#### კარგი seam-ის მახასიათებლები

როგორც უკვე აღვნიშნეთ, **bounded context-ები** შესანიშნავ seams წარმოადგენენ, რადგან ბუნებრივადვე **კოეზიურებიც არიან და სუსტად დაკავშირებულებიც**. ამიტომ პირველი ნაბიჯი ჩვენს კოდში ამ საზღვრების იდენტიფიკაციაა.

ბევრი პროგრამირების ენა გვთავაზობს **namespace-ის** კონცეფციას, რაც საშუალებას გვაძლევს მსგავს კოდს ერთიანად დავაჯგუფოთ. მაგალითად, Java-ში არსებული **package** ამ მიდგომის ერთგვარ მცირე მაგალითს წარმოადგენს. სხვა პოპულარულ ენებშიც არის მსგავსი მექანიზმი, თუმცა JavaScript შეიძლება გამონაკლისად ჩაითვალოს.