
ჩვენ უკვე ვისაუბრეთ რამდენიმე ტექნოლოგიაზე, რომლებიც დაგვეხმარება მოთხოვნა/პასუხის ნიმუშების იმპლემენტაციაში.  
აბა, რა მოხდება მოვლენებზე დაფუძნებული, ასინქრონული კომუნიკაციის შემთხვევაში?


#### ტექნოლოგიური არჩევანი

აქ ორი მთავარი ნაწილია გასათვალისწინებელი:

- გზა, რომლითაც ჩვენი მიკროსერვისები მოვლენებს გააგზავნიან,
    
- და გზა, რომლითაც მომხმარებლები გაიგებენ, რომ ეს მოვლენები მოხდა.
    

ტრადიციულად, მესიჯ ბროკერები, როგორიცაა **RabbitMQ**, ცდილობენ ორივე პრობლემის მოგვარებას.  
პროდიუსერები იყენებენ API-ს, რომ ბროკერს გაუგზავნონ მოვლენა. ბროკერი კი მართავს გამოწერებს, რათა მომხმარებლები ინფორმირებულნი იყვნენ, როცა მოვლენა მოვა.  
ამ ბროკერებს შეუძლიათ მომხმარებელთა მდგომარეობის მართვაც კი  მაგალითად, დაეხმარონ იმაში, თუ რა მესიჯები აქვთ ნანახი.

ეს სისტემები ჩვეულებრივ ისეა შექმნილი, რომ იყოს მასშტაბირებადი და მდგრადი, თუმცა ეს „უფასოდ“ არ მოდის.  
ეს შეიძლება დაამატოს სირთულე განვითარებისა და ტესტირების პროცესს, რადგან თქვენ კიდევ ერთი სისტემა უნდა ამუშევროთ სერვისების დასატესტად.  
დამატებით საჭირო შეიძლება გახდეს მეტი სერვერი და ექსპერტიზა, რომ ინფრასტრუქტურა მუშაობდეს.  
მაგრამ როცა ეს ყველაფერი სწორად დადგება, წარმოუდგენლად ეფექტური გზა შეიძლება აღმოჩნდეს ფრთხილად გაშვებული, მოვლენებზე დაფუძნებული არქიტექტურების იმპლემენტაციისთვის.  
ზოგადად, მე ამ მიდგომის მომხრე ვარ.

თუმცა, ფრთხილად იყავით **middleware-ის სამყაროში**, სადაც მესიჯ ბროკერი მხოლოდ მცირე ნაწილია.  
საწყისში რიგები სრულიად გონივრული და სასარგებლოა. მაგრამ ვენდორებს უყვართ ამ რიგებზე ბევრი პროგრამული უზრუნველყოფის „მიბმა“, რაც იწვევს middleware-ში სულ უფრო მეტი „სმარტის“ გადატანას. ამის მაგალითია **Enterprise Service Bus**.  შეამოწმეთ, რას იღებთ: middleware დატოვეთ მარტივად, და ინტელექტი  _endpoint_-ებში.

კიდევ ერთი მიდგომაა **HTTP-ის გამოყენება მოვლენების გავრცელებისთვის**.  
**ATOM** არის REST-თან თავსებადი სპეციფიკაცია, რომელიც განსაზღვრავს სემანტიკას (სხვა საკითხებთან ერთად) რესურსების „ფიდების“ გამოქვეყნებისათვის.  
არსებობს უამრავი კლიენტური ბიბლიოთეკა, რომლებიც საშუალებას გვაძლევს შევქმნათ და მივიღოთ ეს ფიდები.  
ასე რომ, ჩვენი _customer service_ შეიძლება უბრალოდ ATOM-ფიდში გამოაქვეყნოს მოვლენა, როცა მომხმარებელი შეიცვლება.  
მომხმარებლები კი უბრალოდ „პოლინგით“ ამოწმებენ ამ ფიდს ცვლილებებისთვის.

ერთის მხრივ, ის ფაქტი, რომ შეგვიძლია გამოვიყენოთ უკვე არსებული სპეციფიკაცია და მისი ბიბლიოთეკები სასარგებლოა, თან ვიცით, რომ HTTP კარგად მასშტაბირდება.  
მეორეს მხრივ, HTTP კარგი არაა დაბალი ლატენტურობისთვის (სადაც ზოგი მესიჯ ბროკერი წარმატებით მუშაობს). გარდა ამისა, მომხმარებლებმა თავად უნდა მართონ, რა მესიჯი ნახეს და რა  არა, და polling-ის განრიგიც თვითონ უნდა განსაზღვრონ.

მე მინახავს შემთხვევები, როცა გუნდებმა ძალიან დიდი დრო დახარჯეს ATOM-ისთვის ისეთი ქცევების იმპლემენტაციაში, რაც ბროკერს _out-of-the-box_ მოჰყვება.  
მაგალითად, **Competing Consumer** ნიმუში აღწერს მეთოდს, whereby ამუშავებთ მრავალ worker-ს, რომლებიც ერთმანეთს „ეჯიბრებიან“ მესიჯებზე.  
ეს კარგად მუშაობს, როცა საჭიროა სკეილინგი, მაგრამ გვსურს ავიცილოთ სიტუაცია, როცა ორი worker ერთი და იგივე მესიჯს ხედავს და ერთსა და იმავე საქმეს აკეთებს.  
ბროკერთან ეს ავტომატურად წყდება რიგის საშუალებით.  
ATOM-ის შემთხვევაში კი თქვენ თავად უნდა მართოთ საერთო მდგომარეობა ყველა worker-ს შორის, რომ ძალისხმევა არ გამეორდეს.

თუ უკვე გაქვთ კარგი და მდგრადი მესიჯ ბროკერი, გამოიყენეთ იგი მოვლენების პუბლიკაციისა და გამოწერისთვის.  
თუ არა სცადეთ ATOM, მაგრამ იყავით ფრთხილად **„ჩაძირული ხარჯების შეცდომასთან“**.  
თუ თავს იმაში ამოაცნობთ, რომ სულ უფრო მეტს იმპლემენტირებთ, რაც ბროკერს უკვე აქვს, რაღაც ეტაპზე შეიძლება მოგიწიოთ მიდგომის შეცვლა.

რაც შეეხება იმას, _რას_ ვგზავნით ამ ასინქრონული პროტოკოლებით: იგივე პრინციპები მოქმედებს, რაც სინქრონულ კომუნიკაციაში.  
თუ ახლა კმაყოფილი ხართ JSON-ის გამოყენებით მოთხოვნებისა და პასუხებისთვის გააგრძელეთ.

---

## ასინქრონული არქიტექტურების სირთულეები

ზოგი ეს ასინქრონული რამე თითქოს სახალისოა, არა?  
მოვლენებზე დაფუძნებული არქიტექტურები უფრო დექუპლირებულ და მასშტაბირებად სისტემებს გვთავაზობს. და ეს მართალია.  
მაგრამ ამგვარი პროგრამირების სტილი ზრდის სირთულეს.

ეს არა მხოლოდ პუბლიკაციისა და გამოწერების მართვის სირთულეა, არამედ სხვა პრობლემებიც:  
მაგალითად, გრძელვადიანი ასინქრონული request/response-ისას, უნდა ვიფიქროთ:

- სად მოვა პასუხი? ისევ იმ ნოდზე, რომელიც მოთხოვნას აგზავნიდა?
    
- თუ კი, რა მოხდება, თუ ის ნოდი გათიშულია?
    
- თუ არა, მჭირდება სადმე ინფორმაცია შევინახო, რომ პასუხზე სწორად ვიმოქმედო?
    

მოკლევადიანი ასინქრონულობა უფრო მარტივია, თუ კარგი API-ები გაქვთ, მაგრამ მაინც განსხვავებული აზროვნების სტილს მოითხოვს პროგრამისტებისთვის, რომლებიც სინქრონულ ინტრაპროცესულ გამოძახებებს არიან მიჩვეულნი.

---

## გაფრთხილების ისტორია

2006 წელს მე ბანკისთვის ფასების სისტემას ვქმნიდი.  
ვუყურებდით საბაზრო მოვლენებს და ვგებულობდით, რომელი აქტივები საჭიროებდა გადაფასებას.  
როგორც კი ამ სიას ვადგენდით, ყველაფერს რიგში ვდებდით.  
გვქონდა „grid“, რომელიც ქმნიდა _pricing workers_-ის პულს. ამით შეგვეძლო farm-ის მასშტაბირება.  
ვორკერები იყენებდნენ **Competing Consumer** ნიმუშს თითოეული მესიჯს მაქსიმალური სისწრაფით „იგლეჯდა“.

სისტემა გაეშვა და ჩვენ ძალიან კმაყოფილები ვიყავით.  
მაგრამ ერთ დღეს, ახალი რელიზის შემდეგ, საშინელი პრობლემა დაგვემართა:  
ვორკერები _მუდმივად კვდებოდნენ_.

ბოლოს გავიგეთ, რომ კონკრეტული ტიპის მოთხოვნა worker-ს აშკარად აგდებდათ.  
რიგი ტრანზაქციული იყო: როგორც კი worker კვდებოდა, მის მიერ აღებული მესიჯის lock იწურებოდა და რიგში ბრუნდებოდა.  
მერე სხვა worker იღებდა მას  და ისიც კვდებოდა.  
ეს იყო კლასიკური მაგალითი იმისა, რასაც მარტინ ფაულერი „კატასტროფულ ფეილოვერს“ უწოდებს.

პრობლემა ორმაგი იყო:

1. ბაგი თავად worker-ში.
    
2. ჩვენ არ გვქონდა განსაზღვრული _მაქსიმალური retry ლიმიტი_.
    

retry ლიმიტიც დავამატეთ. გავიგეთ, რომ გვჭირდებოდა გზაც, whereby ცუდი მესიჯების ნახვა და ხელახლა გაშვება შეიძლებოდა.  
ამიტომ გავაკეთეთ **message hospital (ან dead letter queue)**, სადაც ჩავარდნილი მესიჯები მიდიოდა.  
დავამატეთ UI, რომლითაც მათი ნახვა და საჭიროების შემთხვევაში ხელახალი გაშვება შეიძლებოდა.

ეს პრობლემები მაშინვე არ ჩანს, თუ მხოლოდ სინქრონულ კომუნიკაციას ხართ შეჩვეული.

---

## დასკვნა

ასინქრონულ არქიტექტურებთან და პროგრამირებასთან დაკავშირებული სირთულეებიდან გამომდინარე, ვფიქრობ, სიფრთხილით უნდა მიუდგეთ ამ იდეების სწრაფად მიღებას.  
გქონდეთ **კარგი მონიტორინგი**, და სერიოზულად განიხილეთ **correlation ID-ების** გამოყენება, რათა მოთხოვნები პროცესებს შორის დააკვალიანოთ.

ასევე, ძლიერ გირჩევთ წიგნს **Enterprise Integration Patterns (Addison-Wesley)**, რომელიც ბევრად უფრო დეტალურად აღწერს სხვადასხვა პროგრამირების ნიმუშებს, რაც შეიძლება დაგჭირდეთ ამ სფეროში.