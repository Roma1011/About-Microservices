თვითონ ყველაზე გავრცელებული ინტეგრაციის ფორმა, რომელიც მე ან ჩემმა კოლეგებმა ინდუსტრიაში ვნახეთ, არის მონაცემთა ბაზის (DB) ინტეგრაცია. ამ სამყაროში, თუ სხვა სერვისებს სჭირდებათ ინფორმაცია ერთი სერვისიდან, ისინი პირდაპირ მონაცემთა ბაზაში შედიან. და თუ სურთ ცვლილებების შეტანა, კვლავ პირდაპირ ბაზაში მიდიან! პირველად ეს მარტივი ჩანს, და სავარაუდოდ ყველაზე სწრაფი ინტეგრაციის ფორმაა დაწყებისთვის  რაც ახსნიდეს მის პოპულარობას.

ფიგურა 4-1 აჩვენებს ჩვენი რეგისტრაციის UI-ს, რომელიც ქმნის კლიენტებს, პირდაპირ SQL ოპერაციების შესრულებით მონაცემთა ბაზაზე. ასევე ჩანს ჩვენი კოლ-ცენტრის აპლიკაცია, რომელიც ხედავს და აფდეითებს კლიენტების მონაცემებს SQL-ის საშუალებით. ხოლო საწყობი აფდეითებს კლიენტის შეკვეთების ინფორმაციას ბაზის querying-ის გზით. ეს საკმაოდ გავრცელებული სქემა არის, მაგრამ რთული პრობლემებით სავსეა.

![[Pasted image 20250907231902.png]]
#### ფიგურა 4-1

პირველ რიგში, ჩვენ ვაძლევთ გარე მხარეებს საშუალებას ხედონ და შეესაბამონ ჩვენს შიდა იმპლემენტაციის დეტალებს. მონაცემთა სტრუქტურები, რომლებიც მე ვათავსებ DB-ში, ყველასთვის ხელმისაწვდომია; ისინი სრულად იზიარება ყველა სხვა მხარესთან, რომელსაც აქვს წვდომა მონაცემთა ბაზაზე. თუ გადავწყვეტ ჩემი სქემის შეცვლა უკეთესად რომ წარმოაჩინო ჩემი მონაცემები, ან გავამარტივო სისტემის მენეჯმენტი, მე შემიძლია დავაზიანო ჩემი მომხმარებლები. DB ეფექტურად ძალიან დიდი, გაზიარებული APIა, რომელიც ასევე საკმაოდ ნაზი (brittle) არის. თუ მინდა შეცვალო ლოგიკა, მაგალითად, როგორ მართავს helpdesk კლიენტებს და ამისთვის საჭიროა DB-ის ცვლილება, უნდა ვიყო ძალიან ფრთხილი, რომ არ დავაზიანო სქემის ნაწილი, რომელსაც სხვა სერვისები იყენებენ. ეს სიტუაცია ჩვეულებრივ დიდ რაოდენობის regression ტესტირების საჭიროებას იწვევს.

მეორე, ჩემი მომხმარებლები დაკავშირებულნი არიან კონკრეტულ ტექნოლოგიურ არჩევანთან. შესაძლოა ამჟამად გონივრული იყოს კლიენტების შენახვა რელაციურ DB-ში, ამიტომ ჩემი მომხმარებლები იყენებენ შესაბამის (მომავალში შესაძლოა DB-სპეციფიურ) დრაივერს მის დასაკავშირებლად. მაგრამ რა მოხდება, თუ დროთა განმავლობაში მივხვდებით, რომ უკეთესი იქნება მონაცემების შენახვა ნონრელაციურ DB-ში? მომხმარებლები ძალიან მიჯაჭვულნი არიან კლიენტ-სერვისის იმპლემენტაციასთან. როგორც ადრე აღვნიშნეთ, ჩვენ ნამდვილად გვსურს, რომ იმპლემენტაციის დეტალები დამალული იყოს მომხმარებლებისთვის, რათა სერვისს ჰქონდეს ავტონომია შიგნიდან ცვლილებების შეტანისას. გაგვიშვება loose coupling-ისგან.

და ბოლოს, მოდით მოკლედ განვიხილოთ ქცევა (behavior). კლიენტის ცვლილებასთან დაკავშირებული ლოგიკა სად არის? თუ მომხმარებლები პირდაპირ მუშაობენ DB-თან, მაშინ მათ უნდა ეჭირონ დაკავშირებული ლოგიკა. იგივე ტიპის მანიპულაციების ლოგიკა კლიენტზე ახლა შეიძლება გავრცელდეს მრავალი მომხმარებლის შორის. თუ საწყობი, რეგისტრაციის UI და კოლ-ცენტრის UI ყველა უნდა შეასწოროს კლიენტის ინფორმაცია, მე უნდა მოვახდინო შეცდომის კოდი ან ცვლილების შეტანა სამ სხვადასხვა ადგილას და გადავ Deploy-ო ეს ცვლილებები. დაგვაშორებს cohesion-ისგან.

გაიხსენეთ, როცა ვსაუბრობდით კარგ მიკროსერვისების ძირითადი პრინციპების შესახებ? ძლიერი cohesion და loose coupling  DB ინტეგრაციით ორივეს ვკარგავთ. DB ინტეგრაცია მარტივს ხდის მონაცემთა გაზიარებას, მაგრამ არაფერს აკეთებს ქცევის გაზიარებაზე. ჩვენი შიდა რეპრეზენტაცია პირდაპირ ჩანს მომხმარებლებისთვის, და ძალიან რთულია breaking changes-ის თავიდან აცილება, რაც აუცილებლად იწვევს ნებისმიერი ცვლილების შიშს. დაუშვებელია (ან თითქმის დაუშვებელია) ასეთი მიდგომა.

შემდეგ თავში ჩვენ განვიხილავთ სხვადასხვა სტილს ინტეგრაციისთვის, რომელიც მოიცავს თანამშრომლობით სერვისებს, რომლებიც თავის მხრივ მალავენ საკუთარ შიდა რეპრეზენტაციებს.