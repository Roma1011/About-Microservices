მიკროსერვისები არის პატარა, ავტონომიური სერვისები, რომლებიც ერთად მუშაობენ. მოდი ეს განსაზღვრება დავყოთ ნაწილებად და განვიხილოთ ის მახასიათებლები, რომლებიც მიკროსერვისებს სხვებისგან განსხვავებულს ხდის.

### პატარა და ორიენტირებული ერთ საქმეზე, რომელიც კარგად გამოსდის

კოდის ბაზა იზრდება მაშინ, როცა ახალ ფუნქციონალს ვამატებთ. დროთა განმავლობაში, იმდენად დიდდება კოდი, რომ რთული ხდება ზუსტად იცოდე, სად უნდა გააკეთო ცვლილება. მიუხედავად იმისა, რომ ვცდილობთ მონოლითური კოდის ბაზა იყოს მკაფიო და მოდულური, ხშირად ეს თვითნებური შიდა საზღვრები ირღვევა. ფუნქციებთან დაკავშირებული კოდი იწყებს გაფანტვას, რაც ბაგების გასწორებას ან ახალი იმპლემენტაციების გაკეთებას ართულებს.

მონოლითურ სისტემაში ამ ძალებს ვუპირისპირდებით cohesive კოდის შექმნით — ანუ ვცდილობთ კოდი იყოს შეკრული, ხშირად აბსტრაქციებისა და მოდულების საშუალებით. **კოჰეზია** იდეა, რომ დაკავშირებული კოდი ერთად უნდა იყოს მოთავსებული  მნიშვნელოვანი კონცეფციაა მიკროსერვისებზე ფიქრისას. ამას აძლიერებს რობერტ მარტინის **Single Responsibility Principle**-ის განმარტებაც: _„ერთად შეკრიბე ის ელემენტები, რომლებიც ერთი და იგივე მიზეზით იცვლება, და განცალკევე ის, რომლებიც სხვადასხვა მიზეზით იცვლება“_.

მიკროსერვისებიც ამავე მიდგომას იყენებენ დამოუკიდებელ სერვისებზე. ჩვენ ვაშენებთ სერვისის საზღვრებს ბიზნესის საზღვრებზე დაყრდნობით, რაც აშკარას ხდის, სად არის მოცემული ფუნქციონალის კოდი. ამავე დროს, თუ სერვისი მკაფიო საზღვრებზეა დაფოკუსებული, ვირიდებთ ცდუნებას, რომ ის ძალიან დიდი გახდეს და შემოიტანოს სირთულეები.

ხშირად მეკითხებიან: რამდენად პატარა უნდა იყოს მიკროსერვისი? კოდის ხაზებით ზომის განსაზღვრა პრობლემურია, რადგან ზოგი პროგრამირების ენა უფრო გამოხატულია და ნაკლებ ხაზში მეტს აკეთებს. ასევე გასათვალისწინებელია, რომ შეიძლება ბევრ დამოკიდებულებას ვიყენებდეთ, რომლებიც თავად შეიცავენ დიდ კოდს. ზოგჯერ დომენის ნაწილი ბუნებრივად კომპლექსურია და მეტ კოდს მოითხოვს. მაგალითად, Jon Eaves (RealEstate.com.au, ავსტრალია) ამბობს, რომ მიკროსერვისი ისეთი რამ უნდა იყოს, რაც ორ კვირაში თავიდან შეიძლება დაიწეროს  მისი კონტექსტისთვის ეს პრაქტიკული წესი აღმოჩნდა.

კიდევ ერთი პასუხი, რაც შეიძლება ოდნავ ტრივიალურად მოგეჩვენოთ, არის: **„პატარა საკმარისად, მაგრამ არა ზედმეტად პატარა“**. კონფერენციებზე ხშირად ვეკითხები: ვის აქვს სისტემა, რომელიც ძალიან დიდია და გსურთ დაიყოს? თითქმის ყველა ხელს სწევს. ადამიანებს კარგი ინტუიცია გვაქვს იმის გარჩევაში, რა არის ძალიან დიდი, ამიტომ შეიძლება ითქვას, რომ თუ კოდი აღარ გვეჩვენება ზედმეტად დიდად, ის უკვე საკმარისად პატარაა.

მნიშვნელოვანი ფაქტორი ამ კითხვაზე პასუხის გაცემაში არის **თუ რამდენად კარგად ესადაგება სერვისი გუნდის სტრუქტურას**. თუ კოდის ბაზა ძალიან დიდია მცირე გუნდისთვის, მისი დაყოფა სწორი გადაწყვეტილებაა. ამაზე უფრო დაწვრილებით მოგვიანებით ვისაუბრებთ.

ჩემთვის „რამდენად პატარაა საკმარისად პატარა“ ასე ითარგმნება: **რაც უფრო პატარაა სერვისი, მით უფრო იზრდება როგორც მიკროსერვისული არქიტექტურის უპირატესობები, ასევე მისი ნაკლოვანებები.** მცირე ზომის სერვისები უფრო დამოუკიდებელნი არიან, მაგრამ იზრდება სირთულე, რომელიც მრავალი მოძრავი ნაწილისგან გამომდინარეობს. ამ წიგნის განმავლობაში სწორედ ამ სირთულეებზე ვიმსჯელებთ. როცა შეძლებთ უკეთ მართოთ ეს სირთულე, შეგიძლიათ უფრო და უფრო მცირე სერვისებზე გადახვიდეთ.

### ავტონომიურობა

მიკროსერვისი არის დამოუკიდებელი ერთეული. შეიძლება დაინსტალირდეს როგორც იზოლირებული სერვისი **PAAS** პლატფორმაზე, ან იყოს საკუთარი **ოპერაციული სისტემის პროცესი**. ვცდილობთ ერთსა და იმავე მანქანაზე რამდენიმე სერვისი ერთად არ ჩავტვირთოთ, თუმცა „მანქანის“ განსაზღვრება დღეს საკმაოდ ბუნდოვანია. მიუხედავად იმისა, რომ ეს იზოლაცია დამატებით ხარჯებს იწვევს, შედეგად სისტემა გაცილებით მარტივი ხდება და თანამედროვე ტექნოლოგიები ამ Deployment-ის გამოწვევებს კარგად უმკლავდებიან.

სერვისებს შორის კომუნიკაცია ხდება მხოლოდ **ქსელური ზარებით**, რაც უზრუნველყოფს სერვისების განცალკევებას და თავიდან გვაცილებს მჭიდრო კავშირის საფრთხეებს.

ეს სერვისები უნდა შეეძლოს **დამოუკიდებლად შეიცვალონ და განთავსდნენ**, ისე რომ მომხმარებლებს ცვლილება არ დასჭირდეთ. აქედან გამომდინარე, მნიშვნელოვანია გვესმოდეს: რა უნდა გამოაჩინოს სერვისმა და რა უნდა დამალოს. თუ ზედმეტად ბევრს გავაზიარებთ, მომხმარებელი სერვისები ჩვენს შიდა დეტალებზე დამოკიდებულები ხდებიან. ეს ართმევს ავტონომიურობას, რადგან ცვლილების დროს დამატებით კოორდინაციას მოითხოვს.

ჩვენი სერვისი გამოაჩენს **API-ს**, ხოლო სხვა სერვისები ჩვენთან სწორედ ამ API-ების მეშვეობით ურთიერთობენ. ასევე გასათვალისწინებელია, რა ტექნოლოგია ავირჩიოთ, რათა თვითონ API-მაც კი არ დააკავშიროს ზედმეტად მომხმარებლები. ხშირად საჭიროა ტექნოლოგიურად ნეიტრალური API-ების გამოყენება, რომ მომავალში არჩევანი არ შეიზღუდოს.

თუ კავშირი არ არის სათანადოდ დაშლილი, ყველაფერი ინგრევა. მთავარი წესი ასეთია: **შეგიძლია თუ არა სერვისის ცვლილება და დამოუკიდებლად განთავსება ისე, რომ სხვაგან არაფერი შეცვალო?** თუ პასუხი „არაა“, მაშინ ამ წიგნში განხილული უპირატესობების მიღწევა გაგიჭირდებათ.

სწორად განცალკევებისთვის საჭიროა სწორად დავმოდელოთ სერვისები და API-ებიც კარგად განვსაზღვროთ. ამაზე ბევრჯერ დავბრუნდებით.

## ძირითადი უპირატესობები

მიკროსერვისების უპირატესობები მრავალფეროვანია. მათი ნაწილი ნებისმიერ დისტრიბუციულ სისტემას ახასიათებს, თუმცა მიკროსერვისები ამ სარგებელს უფრო მაღალ დონეზე აღწევენ, რადგან ისინი უფრო შორს მიდიან დისტრიბუციული სისტემებისა და სერვისზე ორიენტირებული არქიტექტურის კონცეფციების რეალიზაციაში.

### ტექნოლოგიური ჰეტეროგენულობა

როდესაც სისტემა შედგება მრავალ, ერთმანეთთან თანამშრომელ სერვისისგან, შეგვიძლია თითოეულში სხვადასხვა ტექნოლოგიის გამოყენება. ეს საშუალებას გვაძლევს ავირჩიოთ **სწორი ინსტრუმენტი თითოეული ამოცანისთვის**, ნაცვლად იმისა, რომ გამოვიყენოთ ერთიანი, სტანდარტიზებული მიდგომა „ყველასთვის ერთი ზომა“, რომელიც ხშირად ყველაზე სუსტი ვარიანტია.

თუ ჩვენი სისტემის ერთ ნაწილს სჭირდება პროდუქტიულობის გაუმჯობესება, შეიძლება გადავწყვიტოთ ისეთი ტექნოლოგიური სტეკის გამოყენება, რომელიც უკეთ პასუხობს ამ მოთხოვნას. შესაძლოა, მონაცემების შენახვის სტრატეგიაც სხვადასხვანაირი იყოს სისტემის სხვადასხვა ნაწილში. მაგალითად, სოციალური ქსელისთვის მომხმარებელთა ურთიერთქმედებები შეიძლება **გრაფზე ორიენტირებულ მონაცემთა ბაზაში** შევინახოთ, რადგან ისინი ძლიერად დაკავშირებულია, ხოლო პოსტები  **დოკუმენტზე ორიენტირებულ საცავში**. შედეგად გვექნება ჰეტეროგენული არქიტექტურა (როგორც ნახაზში 1-1).
![[Pasted image 20250904163206.png]] სურათი 1-1.


მიკროსერვისები საშუალებას გვაძლევენ **უფრო სწრაფად დავნერგოთ ახალი ტექნოლოგიები** და გავიგოთ, როგორ შეიძლება ისინი დაგვეხმარონ. მონოლითურ აპლიკაციაში თუ მინდა ახალი ენის, მონაცემთა ბაზის ან ჩარჩოს ცდა, ეს ცვლილება მთელ სისტემას ეხება. ხოლო მრავალსერვისიან სისტემაში შემიძლია ავირჩიო შედარებით ნაკლებად რისკიანი სერვისი და იქ ვცადო. ამით ზღუდავ შესაძლო უარყოფით ეფექტს. ბევრი ორგანიზაციისთვის ახალი ტექნოლოგიების სწრაფად ათვისების უნარი სერიოზულ უპირატესობას წარმოადგენს.

მრავალ ტექნოლოგიასთან მუშაობას, ბუნებრივია, თავისი ხარჯიც აქვს. ზოგი ორგანიზაცია გარკვეულ შეზღუდვებს აწესებს. მაგალითად, **Netflix** და **Twitter** ძირითადად **JVM** პლატფორმას იყენებენ, რადგან კარგად იცნობენ მის საიმედოობასა და პროდუქტიულობას. მათ ასევე აქვთ შექმნილი საკუთარი ბიბლიოთეკები და ხელსაწყოები JVM-ზე, რაც მასშტაბურ მუშაობას ამარტივებს, თუმცა ართულებს არაჯავას სერვისებისთვის ინტეგრაციას. მაგრამ არც ერთ მათგანს არ აქვს მხოლოდ ერთი სტეკი ყველა ამოცანისთვის.  
მეორე მხრივ, თუ მართლა შეიძლება მიკროსერვისი ორ კვირაში თავიდან დაიწეროს, მაშინ ახალი ტექნოლოგიის დანერგვის რისკიც უფრო ადვილად მართვადი ხდება.

როგორც ამ წიგნში ბევრჯერ ნახავთ, მიკროსერვისებში ყველაფერი სწორ ბალანსზე მოდის. ტექნოლოგიურ არჩევანებზე უფრო დაწვრილებით ვისაუბრებთ **მეორე თავში** (ევოლუციური არქიტექტურა), ხოლო **მეოთხე თავში** განვიხილავთ ინტეგრაციას და იმას, როგორ უზრუნველვყოთ, რომ სერვისებს შეეძლოთ ტექნოლოგიურად დამოუკიდებლად განვითარება ზედმეტი კავშირის გარეშე.

### გამძლეობა (Resilience)

გამძლეობის ინჟინერიაში ერთ-ერთი საკვანძო ცნებაა **bulkhead** (იზოლაციური კედელი). თუ სისტემის ერთ კომპონენტს გაუჩნდა ხარვეზი, მაგრამ ეს ხარვეზი არ ვრცელდება სხვებზე, პრობლემა იზოლირდება და დანარჩენი სისტემა მუშაობას აგრძელებს. სერვისული საზღვრები სწორედ ასეთი bulkhead-ებია.

მონოლითურ სერვისში თუ სერვისი ჩავარდა  ყველაფერი ჩერდება. მართალია, შეგვიძლია მონოლითი რამდენიმე მანქანაზე გავუშვათ, რათა ჩავარდნის რისკი შევამციროთ, მაგრამ მიკროსერვისებში შეგვიძლია ავაშენოთ სისტემა, რომელიც გაუძლებს ცალკეული სერვისის სრული ჩავარდნას და მხოლოდ ნაწილობრივ დაკარგავს ფუნქციონალს.

ამასთან, სიფრთხილე აუცილებელია. მიკროსერვისულ სისტემებს ახალი ჩავარდნის წყაროებიც ახლავს: **ქსელები შეიძლება ჩავარდეს, ისევე როგორც მანქანები**. უნდა ვიცოდეთ, როგორ ვუმკლავდებით ამას და რა გავლენა ექნება საბოლოო მომხმარებელზე. 

### მასშტაბირება (Scaling)

დიდ მონოლითურ სერვისში ყველაფრის ერთად მასშტაბირება გვიწევს. შესაძლოა სისტემის მხოლოდ პატარა ნაწილი იყოს პროდუქტიულობის ბოთლის ყელი, მაგრამ თუ ეს ქცევა დიდ მონოლითშია ჩაკეტილი, მაინც მთელ აპლიკაციას უნდა მოვუმატოთ რესურსი. მცირე სერვისებში კი შეგვიძლია მხოლოდ ის სერვისები გავზარდოთ, რომლებსაც სჭირდებათ, დანარჩენი კი უფრო სუსტი აპარატურაზეც გავუშვათ (ნახაზი 1-2).
![[Pasted image 20250904163549.png]]
სურათი 1-2.

**Gilt** (ონლაინ მოდის მაღაზია) სწორედ ამ მიზეზით გადავიდა მიკროსერვისებზე. 2007 წელს მონოლითურ **Rails**-ის აპლიკაციით დაიწყეს, მაგრამ 2009-ში დატვირთვას ვეღარ უმკლავდებოდნენ. სისტემის ძირითადი ნაწილების გამოყოფით მათ შეძლეს ტრაფიკის პიკებთან გამკლავება. დღეს კი 450-ზე მეტი მიკროსერვისი აქვთ, თითოეული  მრავალ დამოუკიდებელ მანქანაზე.

თუ გამოვიყენებთ მოთხოვნაზე დაფუძნებულ რესურსების გამოყოფას (მაგ., **Amazon Web Services**), მასშტაბირებაც მხოლოდ იმ ნაწილებზე შეგვიძლია დავამატოთ, სადაც საჭირო იქნება. ეს საშუალებას გვაძლევს **ხარჯებიც უკეთ ვაკონტროლოთ**. იშვიათად ხდება ისე, რომ არქიტექტურულ მიდგომას პირდაპირი და სწრაფი ხარჯების შემცირება მოჰყვეს.


### განთავსების სიმარტივე (Ease of Deployment)

როდესაც მილიონხაზიან მონოლითურ აპლიკაციაში ერთი ხაზის ცვლილებას ვაკეთებთ, მთელი აპლიკაციის თავიდან განთავსებაა საჭირო. ეს ხშირად დიდწილად გავლენიანი და მაღალი რისკის deployment-ია. პრაქტიკაში ასეთი მასშტაბური, მაღალი რისკის განთავსებები იშვიათად კეთდება — და ეს გასაგები შიშითაცაა განპირობებული. მაგრამ, სამწუხაროდ, ეს იმასაც ნიშნავს, რომ ცვლილებები release-ებს შორის გროვდება, ხოლო როდესაც ახალი ვერსია პროდაქშენში ხვდება, მასში უკვე ძალიან ბევრი ცვლილებაა. და რაც უფრო დიდია release-ებს შორის სხვაობა, მით უფრო მაღალია შეცდომის რისკიც.

მიკროსერვისებში შეგვიძლია მხოლოდ ერთი სერვისის ცვლილება განვათავსოთ დამოუკიდებლად დანარჩენი სისტემისგან. ეს საშუალებას გვაძლევს კოდი უფრო სწრაფად მივიტანოთ პროდაქშენში. თუ პრობლემა წარმოიშვება, მისი იზოლირება შესაძლებელია კონკრეტულ სერვისამდე, რაც rollback-ს ძალიან ამარტივებს. ასევე, ეს ნიშნავს, რომ ახალ ფუნქციონალს მომხმარებლებს უფრო სწრაფად მივაწვდით. სწორედ ეს არის ერთ-ერთი მთავარი მიზეზი, რატომ იყენებენ **Amazon** და **Netflix** მიკროსერვისულ არქიტექტურას — რათა მაქსიმალურად მოაშორონ ყველა დაბრკოლება პროგრამული უზრუნველყოფის სწრაფ გამოშვებას.

ბოლო წლებში ამ სფეროში ტექნოლოგია მნიშვნელოვნად შეიცვალა, და **მე-6 თავში** უფრო ღრმად შევეხებით მიკროსერვისულ გარემოში deployment-ის თემას.

### ორგანიზაციული სწორად მორგება (Organizational Alignment)

ბევრს გვქონია გამოცდილება დიდი გუნდებითა და დიდი კოდის ბაზებით გამოწვეული პრობლემებისა. თუ გუნდი დისტრიბუცირებულია, ეს პრობლემები კიდევ უფრო მძაფრდება. ამავე დროს ვიცით, რომ მცირე გუნდები მცირე კოდის ბაზაზე უფრო პროდუქტიულები არიან.

მიკროსერვისები საშუალებას გვაძლევს არქიტექტურა უკეთ მოვარგოთ ორგანიზაციას  მინიმუმამდე დავიყვანოთ იმ ადამიანების რაოდენობა, ვინც ერთ კოდის ბაზაზე მუშაობს, და ამით მოვარტყათ „ტკბილ წერტილს“ გუნდის ზომასა და პროდუქტიულობას შორის. ასევე შეგვიძლია სერვისების მფლობელობა გადავანაწილოთ გუნდებს შორის ისე, რომ კონკრეტული სერვისზე მომუშავე ადამიანები მაქსიმალურად ერთად იყვნენ. ამ თემას უფრო დაწვრილებით განვიხილავთ **მე-10 თავში**, სადაც **Conway’s Law**-ზეც ვისაუბრებთ.

### კომპოზიციურობა (Composability)

დისტრიბუციული სისტემებისა და სერვისზე ორიენტირებული არქიტექტურების ერთ-ერთი მთავარი დაპირებაა ფუნქციონალის ხელახალი გამოყენების შესაძლებლობა. მიკროსერვისებით ჩვენ ვაძლევთ საშუალებას ფუნქციონალს სხვადასხვა გზით და სხვადასხვა მიზნებისთვის იქნას მოხმარებული.

ეს განსაკუთრებით მნიშვნელოვანია, როცა ვფიქრობთ იმაზე, როგორ იყენებენ ჩვენს პროგრამულ უზრუნველყოფას მომხმარებლები. აღარ არის დრო, როცა მხოლოდ desktop ვებსაიტზე ან მობილურ აპლიკაციაზე ვფიქრობდით. დღეს უნდა განვიხილოთ უამრავი გზა — ვები, native აპლიკაცია, მობილური ვებ-გვერდი, ტაბლეტის აპი თუ smart მოწყობილობა. როგორც კი ორგანიზაციები ვიწრო არხებიდან გადადიან მომხმარებელთან ურთიერთობის უფრო ჰოლისტურ მიდგომებზე, საჭირო ხდება ისეთი არქიტექტურები, რომლებიც ამ ცვლილებებს ფეხს აუწყებენ.

მიკროსერვისებით შეგვიძლია სისტემაში „სელები“ გავხსნათ, რომლებიც გარე მხარეებისთვის ხელმისაწვდომია. ვითარების შეცვლისას შეგვიძლია ფუნქციონალი სხვადასხვა გზით ავაწყოთ. მონოლითურ აპლიკაციაში ხშირად ერთი უხეში „სელი“ გვაქვს გარე გამოყენებისთვის. თუ მინდა ის უფრო სასარგებლოდ დავყო, მჭიდის მაგივრად მჭედელოს ჩაქუჩი მჭირდება! **მე-5 თავში** განვიხილავთ გზებს, როგორ შეიძლება არსებული მონოლითების დაშლა ხელახალად გამოყენებად, კომპოზიციურ მიკროსერვისებად.

### ჩანაცვლებადობაზე ოპტიმიზაცია (Optimizing for Replaceability)

თუ საშუალო ან დიდ ორგანიზაციაში მუშაობთ, ალბათ იცით დიდი და არასასიამოვნო ლეგასის სისტემის არსებობა — ის, რომელსაც არავინ ეკარება, მაგრამ მაინც კრიტიკულია კომპანიის მუშაობისთვის. ხშირად ასეთი სისტემა დაწერილია უცნაურ **Fortran**-ის ვარიაციაზე და მუშაობს აპარატურაზე, რომელსაც უკვე 25 წელია ვადა გაუვიდა. რატომ არ ჩანაცვლდა? იმიტომ რომ საქმე ზედმეტად დიდსა და რისკიანს წარმოადგენს.

მიკროსერვისებში, რადგან ისინი მცირე ზომის არიან, მათი ჩანაცვლება უკეთესი იმპლემენტაციით ან საერთოდ წაშლა ბევრად უფრო ადვილია. რამდენჯერ გქონიათ შემთხვევა, რომ ერთ დღეში ასზე მეტი კოდის ხაზი წაგიშლიათ და დიდად არ გდარდიათ? მიკროსერვისები ხშირად დაახლოებით ამ ზომის არიან, ამიტომ მათი თავიდან დაწერა ან მოცილება დაბრკოლებებს ნაკლებად ქმნის.

მიკროსერვისულ მიდგომას მიმდევარი გუნდები მშვიდად კლებენ სერვისებს, როცა საჭირო ხდება, ან სრულიად თავიდან წერენ. როცა კოდის ბაზა მხოლოდ რამდენიმე ასეული ხაზია, ადამიანები იშვიათად ემოციურად ებმებიან მასში, და მისი ჩანაცვლების ფასი ძალიან მცირეა.


შემდეგი [[SOA ს შესახებ]]