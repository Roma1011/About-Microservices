**Representational State Transfer (REST)**  ეს არის არქიტექტურული სტილი, შთაგონებული ვებისგან. REST სტილს მრავალი პრინციპი და შეზღუდვა აქვს, მაგრამ აქ გავამახვილებთ ყურადღებას იმაზე, რაც ნამდვილად გვეხმარება ინტეგრაციის გამოწვევებისას მიკროსერვისების სამყაროში და როცა RPC-ს ალტერნატიულ სტილს ვეძებთ სერვისის ინტერფეისებისთვის.

ყველაზე მნიშვნელოვანი არის **რესურსის** კონცეფცია. რესურსი შეგიძლიათ განიხილოთ, როგორც ობიექტი, რომელიც სერვისს აქვს  მაგალითად, **Customer**. სერვერი ქმნის ამ Customer-ის სხვადასხვა წარმოდგენას მოთხოვნის შესაბამისად. როგორ გამოჩნდება რესურსი გარედან, მთლიანად დეკუპლირებულია შიდა შენახვის ფორმისგან. კლიენტმა შეიძლება მოითხოვოს Customer-ის JSON წარმოდგენა, მიუხედავად იმისა, რომ შიგნით სხვა ფორმატშია შენახული. როცა კლიენტი იღებს Customer-ის წარმოდგენას, მას შეუძლია მოითხოვოს ცვლილებები, და სერვერმა შეიძლება შეასრულოს ისინი ან არა.

REST-ის ბევრი სხვადასხვა სტილია, მაგრამ აქ მხოლოდ მოკლედ შევეხებით. ძალიან გირჩევთ **Richardson Maturity Model**-ის გაცნობას, სადაც REST-ის სხვადასხვა სტილი შედარებულია.

REST თავისთავად არაფერს ამბობს ძირითადი პროტოკოლების შესახებ, თუმცა ყველაზე ხშირად გამოიყენება **HTTP**-ზე. 
მე მინახავს REST-ის იმპლემენტაციები სრულიად განსხვავებული პროტოკოლებითაც (მაგალითად, serial ან USB), თუმცა ეს დიდ შრომას მოითხოვს. 
HTTP-ში არსებული შესაძლებლობები  მაგალითად, **verbs**  REST-ის იმპლემენტაციას ამარტივებს, სხვა პროტოკოლებზე კი ეს შესაძლებლობები თვითონ უნდა განვახორციელოთ.


#### REST და HTTP

HTTP თავად განსაზღვრავს სასარგებლო შესაძლებლობებს, რომლებიც REST სტილს ძალიან ერგება. მაგალითად, HTTP-ის **verbs** (GET, POST, PUT და სხვ.) 
უკვე განსაზღვრული მნიშვნელობებით მოდის HTTP-ის სპეციფიკაციაში და პირდაპირ უკავშირდება რესურსებთან მუშაობას. REST ამბობს, რომ მეთოდები ყველა რესურსზე ერთნაირად უნდა იქცეოდეს, და HTTP სწორედ ასეთ მეთოდებს გვაძლევს.

- **GET** ― იღებს რესურსს idempotent ფორმაში.
    
- **POST** ― ქმნის ახალ რესურსს.
    

ეს გვაძლევს საშუალებას, ავირიდოთ მრავალი განსხვავებული მეთოდი (მაგ., `createCustomer`, `editCustomer`). უბრალოდ ვაგზავნით Customer-ის წარმოდგენას **POST** ით ახალი რესურსის შესაქმნელად, ხოლო **GET**-ით ვიღებთ მის წარმოდგენას.

კონცეპტუალურად, აქ გვაქვს ერთი endpoint  Customer რესურსი, ხოლო ოპერაციები baked-ია HTTP პროტოკოლში.

HTTP-ს ასევე აქვს დიდი ეკოსისტემა დამხმარე ხელსაწყოებით. შეგვიძლია გამოვიყენოთ **HTTP caching proxies** (მაგ., Varnish), **load balancers** (მაგ., mod_proxy), და ბევრი მონიტორინგის ხელსაწყო უკვე პირდაპირ მხარს უჭერს HTTP-ს. 
ეს ბლოკები საშუალებას გვაძლევს, გავუმკლავდეთ HTTP ტრაფიკის დიდ მოცულობებს და სწორად გავანაწილოთ ისინი. უსაფრთხოების მხრივაც HTTP-ს ეკოსისტემა მდიდარია: **basic auth**, **client certs** და სხვა.

თუმცა ამ სარგებლის მისაღებად **HTTP სწორად უნდა გამოიყენოთ**. თუ ცუდად გამოვიყენებთ, ის დაუცველი და რთული გასაფართოებელი იქნება, როგორც ნებისმიერი სხვა ტექნოლოგია. სწორად გამოყენების შემთხვევაში კი ძალიან დიდ დახმარებას იღებთ.

გაითვალისწინეთ: HTTP-ს RPC-ის იმპლემენტაციისთვისაც იყენებენ. მაგალითად, **SOAP** გადის HTTP-ზე, მაგრამ პრაქტიკაში ძალიან ცოტას იყენებს სპეციფიკაციიდან. იგნორირებულია **verbs**, აგრეთვე ისეთი ელემენტარული რაღაცებიც, როგორიცაა HTTP error codes. ხშირად, ნაცვლად არსებული, კარგად გაგებული სტანდარტებისა, იგონებენ ახალს რომელსაც მხოლოდ ახალი ხელსაწყოებით ახორციელებენ, და ისინი, თავის მხრივ, იმავე კომპანიებისგანაა მოწოდებული, ვინც ეს სტანდარტი შექმნა.


#### Hypermedia as the Engine of Application State (HATEOAS)

REST-ში შემოტანილი კიდევ ერთი პრინციპი, რომელიც კლიენტისა და სერვერის შორის coupling-ს ამცირებს, არის **hypermedia as the engine of application state** (HATEOAS).

**Hypermedia** ნიშნავს, რომ კონტენტში ლინკებია ჩაშენებული სხვა კონტენტზე (ტექსტი, სურათი, ხმა და ა.შ.). ნაცნობია ჩვენთვის ეს ჩვეულებრივი ვებგვერდია. 
HATEOAS-ის იდეაა, რომ კლიენტმა ურთიერთქმედება (state transitions) სერვერთან ამ ლინკების მეშვეობით განახორციელოს. ანუ კლიენტს არ სჭირდება წინასწარ იცოდეს URI, ის უბრალოდ მიჰყვება ბმულებს.

მაგალითად, ვიფიქროთ **Amazon.com**-ზე. კალათის მდებარეობა, გრაფიკა და ლინკი დროთა განმავლობაში იცვლებოდა, მაგრამ ადამიანები მაინც პოულობდნენ კალათას და იყენებდნენ. რადგან ვიცით მისი მნიშვნელობა. სწორედ ამიტომ ვებგვერდები შეიძლება ინკრემენტულად იცვლებოდეს, ისე რომ მომხმარებელი არ დაიკარგოს.

HATEOAS ცდილობს იგივე შესაძლებლობა მისცეს ელექტრონულ კლიენტებს.

<album>
  <name>Give Blood</name>
  <link rel="/artist" href="/artist/theBrakes" />
  <description>
    Awesome, short, brutish, funny and loud. Must buy!
  </description>
  <link rel="/instantpurchase" href="/instantPurchase/1234" />
</album>

ქ გვაქვს ორი **hypermedia control**:

- `artist` → გვიჩვენებს, სად ვიპოვოთ არტისტის ინფორმაცია.
    
- `instantpurchase` → გვიჩვენებს, სად შევიძინოთ ალბომი.
    

კლიენტს არ სჭირდება წინასწარ იცოდეს URI. უბრალოდ პოულობს შესაბამის კონტროლს და მიჰყვება. ეს **დიდ დეკუპლირებას** იძლევა.


### უპირატესობები და კომპრომისები

- შეგვიძლია მთლიანად შევცვალოთ control-ის იმპლემენტაცია ისე, რომ კლიენტი მაინც მუშაობდეს.
    
- შეგვიძლია დავამატოთ ახალი controls (ახალი state transitions), მომხმარებლების მოტეხვის გარეშე.
    
- მხოლოდ მაშინ ვწყვეტთ კონტრაქტს, თუ semantics შეიცვალა რადიკალურად ან control საერთოდ წავშალეთ.
    

ეს მიდგომა იძლევა დიდ სარგებელს დროთა განმავლობაში. კლიენტი **პროგრესულად აღმოაჩენს API-ს** რაც ძალიან სასარგებლოა ახალი კლიენტების იმპლემენტაციისას.

**ნაკლოვანება:** შეიძლება გახდეს “chatty”  ანუ კლიენტს უწევს ბევრი ლინკის მიყოლა სასურველ ოპერაციამდე მისასვლელად. თუმცა ეს არის **trade-off**. რეკომენდებულია, რომ თავიდან კლიენტები მიჰყვნენ controls-ს, და საჭიროების შემთხვევაში მერე გავაკეთოთ ოპტიმიზაცია.

მე პირადად **მომწონს** ლინკების გამოყენება API-ს ნავიგაციისთვის. სარგებელი  პროგრესული აღმოჩენა და coupling-ის შემცირება სერიოზულია. მაგრამ ბევრ ადგილას ჯერ კიდევ იშვიათად გამოიყენება. ჩემი აზრით, ამის მიზეზი upfront შრომაა, მაშინ როცა სარგებელი მოგვიანებით ჩანს.


#### JSON, XML, თუ რაღაც სხვა?

სტანდარტული ტექსტური ფორმატების გამოყენება კლიენტებს ბევრ მოქნილობას აძლევს რესურსების მოხმარების თვალსაზრისით, და REST–ი HTTP–ზე გვაძლევს საშუალებას გამოვიყენოთ სხვადასხვა ფორმატი. აქამდე მოცემულ მაგალითებში XML გამოვიყენე, მაგრამ ამ ეტაპზე JSON ბევრად უფრო პოპულარული შიგთავსის ტიპია იმ სერვისებისთვის, რომლებიც HTTP–ს იყენებენ.

იმ ფაქტმა, რომ JSON ბევრად უფრო მარტივი ფორმატია, იმასაც ნიშნავს, რომ მოხმარებაც უფრო იოლია. ზოგიერთი მომხრე მის შედარებით კომპაქტურობასაც ასახელებს XML–თან შედარებით, როგორც დამატებით უპირატესობას, თუმცა ეს რეალურ სამყაროში იშვიათად არის პრობლემა.

თუმცა JSON–ს აქვს გარკვეული მინუსებიც. XML განსაზღვრავს ბმულის კონტროლს, რომელსაც ჩვენ მანამდე გამოვიყენეთ, როგორც ჰიპერმედიას კონტროლი. JSON–ის სტანდარტი მსგავსს არაფერს განსაზღვრავს, ამიტომ ხშირად შინაგანად შემუშავებულ სტილებს იყენებენ ამ ცნების ძალით შეჭედვისთვის. Hypertext Application Language (HAL) ცდილობს ეს გამოასწოროს, JSON–ისთვის (და XML–ისთვისაც, თუმცა arguable XML–ს ნაკლები დახმარება სჭირდება) ჰიპერბმულების ზოგადი სტანდარტების განსაზღვრით. თუ HAL–ის სტანდარტს მიჰყვებით, შეგიძლიათ გამოიყენოთ ისეთი ხელსაწყოები, როგორიცაა ვებ–ზე დაფუძნებული HAL browser–ი ჰიპერმედიის კონტროლების გამოსაკვლევად, რაც კლიენტის შექმნას ბევრად გაგიადვილებთ.

რა თქმა უნდა, მხოლოდ ამ ორ ფორმატზე არ ვართ შეზღუდულნი. შეგვიძლია HTTP–ზე გადავაგზავნოთ ფაქტობრივად ნებისმიერი რამ, თუნდაც ბინარული. სულ უფრო და უფრო ბევრს ვხედავ, ვინც უბრალოდ HTML–ს იყენებს ფორმატად XML–ის ნაცვლად. ზოგიერთ ინტერფეისში HTML–ს შეიძლება ორმაგი ფუნქცია ჰქონდეს  როგორც UI–ს, ასევე API–ს სახით, თუმცა აქ გარკვეული საფრთხეები არსებობს, რადგან ადამიანის და კომპიუტერის ინტერაქცია ძალიან განსხვავდება! მაგრამ იდეა ნამდვილად მიმზიდველია. ბოლოს და ბოლოს, უამრავი HTML parser არსებობს.

პირადად მე მაინც XML–ის გულშემატკივარი ვარ. ზოგიერთ შემთხვევაში ინსტრუმენტული მხარდაჭერა უკეთესია. მაგალითად, თუ მინდა payload–ის მხოლოდ გარკვეული ნაწილების ამოღება (ტექნიკა, რომელზეც ვრცლად ვისაუბრებთ „ვერსიონირების“ თავში), შემიძლია გამოვიყენო XPATH, რომელიც კარგად გაგებული სტანდარტია და უამრავი ინსტრუმენტული მხარდაჭერა აქვს, ან თუნდაც CSS სელექტორები, რაც ბევრისთვის კიდევ უფრო მარტივია. JSON–ისთვის არსებობს JSONPATH, მაგრამ ის ფართოდ მხარდაჭერილი არ არის. ჩემთვის უცნაურია, როცა JSON–ს ირჩევენ იმიტომ, რომ ის მსუბუქია, და მერე ცდილობენ მასში ისეთ ცნებების შეტანას, როგორიცაა ჰიპერმედიის კონტროლები, რომლებიც უკვე არსებობს XML–ში. ვაღიარებ, რომ ალბათ უმცირესობაში ვარ, მაგრამ JSON მაინც უმეტესობისთვის საყვარელი ფორმატია!


#### ფრთხილად ზედმეტი კომფორტის მიმართ

როდესაც REST უფრო და უფრო პოპულარული გახდა, პარალელურად იმატა ისეთმა ჩარჩოებმა, რომლებიც RESTFul ვებ–სერვისების შექმნას გიადვილებენ. თუმცა, ზოგიერთი მათგანი მოკლევადიან სარგებელს იმდენად დიდ მნიშვნელობას ანიჭებს, რომ გრძელვადიან ტკივილს ქმნის; ცდილობენ სწრაფად დაგაწყებინონ, მაგრამ ამავდროულად ხელს უწყობენ ცუდ ქცევებს. მაგალითად, ზოგი ჩარჩო საშუალებას გაძლევს ძალიან მარტივად უბრალოდ აიღო მონაცემთა ბაზის ობიექტების წარმოდგენა, დაასერიალო ისინი პროცესში ობიექტებად და შემდეგ პირდაპირ გარეთ გამოაჩინო. მახსოვს, ერთ კონფერენციაზე ეს Spring Boot–ით დემონსტრირდებოდა და მას დიდ უპირატესობად თვლიდნენ. ის ჩაშენებული კავშირი, რასაც ასეთი მიდგომა იწვევს, უმეტეს შემთხვევაში ბევრად მეტ ტკივილს მოიტანს, ვიდრე იმ კონცეპციების სწორად დეკუპლირებას დასჭირდებოდა ძალისხმევა.

აქ უფრო ზოგადი პრობლემაც დგას. ის, თუ როგორ ვირჩევთ მონაცემების შენახვას და როგორ ვაჩვენებთ მათ მომხმარებლებს, ადვილად შეიძლება დომინანტური გახდეს ჩვენს აზროვნებაში. ერთ-ერთ ჩვენს გუნდში ნანახი მქონდა ნიმუში, სადაც ეფექტურად გამოიყენეს შემდეგი მიდგომა: მიკროსერვისისთვის ნამდვილი პერმანენტული შენახვის დანერგვა გადაიდო მანამ, სანამ ინტერფეისი საკმარისად არ დასტაბილურდა. შუალედურ პერიოდში ერთეულები უბრალოდ ლოკალურ დისკზე ფაილში ინახებოდა, რაც, ცხადია, გრძელვადიანი გადაწყვეტა არ არის. ეს უზრუნველყოფდა, რომ მომხმარებლების საჭიროებები მართავდნენ სერვისის დიზაინსა და იმპლემენტაციას. მოტივაცია იყო ის, რომ ძალიან ადვილია, თუ როგორ ვინახავთ დომენის ერთეულებს საბაზისო საცავში, ძალიან ძლიერად იმოქმედოს იმ მოდელებზე, რომლებსაც ქსელზე ვუგზავნით კოლაბორატორებს. ამ მიდგომის მინუსი ის იყო, რომ მონაცემთა საცავთან მიერთების სამუშაო გვიანდებოდა. თუმცა ვფიქრობ, ახალი სერვისის საზღვრებისთვის ეს მისაღები კომპრომისია.


#### REST–ის მინუსები HTTP–ზე


მოხმარების სიმარტივის თვალსაზრისით, REST–ის HTTP–ზე აგებული აპლიკაციისთვის კლიენტის სტუბის გენერაცია ისე მარტივად არ ხდება, როგორც RPC–ში. რა თქმა უნდა, იმის გამო, რომ HTTP გამოიყენება, შეგიძლიათ ისარგებლოთ ყველა შესანიშნავი HTTP კლიენტის ბიბლიოთეკით, მაგრამ თუ გსურთ ჰიპერმედიის კონტროლების იმპლემენტაცია და გამოყენება კლიენტის მხარეს, პრაქტიკულად მარტო ხართ. ჩემი აზრით, კლიენტის ბიბლიოთეკებს ბევრად უკეთესად უნდა შეეძლოთ ეს, ვიდრე ახლა შეუძლიათ, თუმცა ისინი ნამდვილად უკეთესია, ვიდრე ადრე იყო. მაგრამ ეს მოჩვენებითი სირთულე ხშირად უბიძგებს ხალხს, უკან დაიხიონ და RPC გადატენონ HTTP–ში ან ააგონ საერთო კლიენტის ბიბლიოთეკები. საერთო კოდი კლიენტსა და სერვერს შორის ძალიან სახიფათოა, როგორც ვიხილავთ „DRY და კოდის ხელახალი გამოყენების საფრთხეები მიკროსერვისების სამყაროში“ თავში.

კიდევ ერთი მცირე საკითხია, რომ ზოგიერთ ვებ სერვერის ჩარჩოს HTTP–ის ყველა ზმნის სრულად მხარდაჭერა არ აქვს. მაგალითად, შესაძლოა ძალიან მარტივი იყოს GET ან POST მოთხოვნების ჰენდლერის შექმნა, მაგრამ PUT ან DELETE მოთხოვნებისთვის მოგიწიოთ დიდი ბარიერების გადალახვა. ნამდვილი REST ჩარჩოებს, როგორიცაა Jersey, ეს პრობლემა არ აქვთ და ჩვეულებრივ workaround–საც იპოვით, მაგრამ თუ გარკვეულ ჩარჩოებში ხართ ჩაკეტილი, ეს შეიძლება შეზღუდავდეს REST–ის სტილს, რომელსაც გამოიყენებთ.

პროდუქტიულობა ასევე შეიძლება გახდეს საკითხი. REST over HTTP payload–ები შეიძლება უფრო კომპაქტური იყოს SOAP–ზე, რადგან ის ალტერნატიულ ფორმატებსაც უჭერს მხარს, როგორიცაა JSON ან თუნდაც ბინარული, მაგრამ მაინც ძალიან შორსაა ისეთი პროტოკოლის სიმჭიდროვისგან, როგორიცაა Thrift. HTTP–ს ზედნადები თითოეულ მოთხოვნაზე შეიძლება პრობლემური იყოს დაბალი ლატენტურობის მოთხოვნებისთვის.

HTTP, მართალია, კარგად უხდება დიდი მოცულობის ტრაფიკის მართვას, მაგრამ დაბალი ლატენტურობის კომუნიკაციისთვის არაა საუკეთესო სხვა პროტოკოლებთან შედარებით, რომლებიც TCP–ზე ან სხვა ქსელურ ტექნოლოგიებზე არიან აგებული. მაგალითად, WebSockets–ს, მიუხედავად სახელისა, ძალიან ცოტა კავშირი აქვს Web–თან. საწყისი HTTP handshake–ის შემდეგ ეს უბრალოდ TCP–ს კავშირია კლიენტსა და სერვერს შორის, თუმცა ბევრად უფრო ეფექტური საშუალებაა ბრაუზერისთვის მონაცემების სტრიმინგისთვის. თუ ეს გაინტერესებთ, გაითვალისწინეთ, რომ აქ HTTP–ს ძალიან ცოტა რამ გამოიყენება, REST–ზე კი საერთოდ არაფერი.

სერვერიდან სერვერზე კომუნიკაციისთვის, თუ ძალიან დაბალი ლატენტურობა ან მცირე შეტყობინების ზომა მნიშვნელოვანია, HTTP კომუნიკაცია ზოგადად არ არის კარგი იდეა. თქვენ შეიძლება დაგჭირდეთ სხვა საბაზისო პროტოკოლების არჩევა, მაგალითად UDP, რათა მიაღწიოთ სასურველ წარმადობას, და ბევრი RPC ჩარჩო საკმაოდ ბედნიერად მუშაობს TCP–ს გარდა სხვა ქსელურ პროტოკოლებზეც.

Payload–ების მოხმარება თვითონაც მეტ სამუშაოს მოითხოვს, ვიდრე ზოგიერთ RPC იმპლემენტაციაშია, რომლებიც გაფართოებულ სერიალიზაციის და დესერიალიზაციის მექანიზმებს უჭერენ მხარს. ისინი შეიძლება გახდნენ კავშირის წერტილი კლიენტსა და სერვერს შორის, რადგან ტოლერანტული მკითხველების იმპლემენტაცია არ არის მარტივი საქმე, მაგრამ სწრაფად დაწყების კუთხით ისინი საკმაოდ მიმზიდველია.

ამ მინუსების მიუხედავად, REST over HTTP გონივრული ნაგულისხმევი არჩევანია სერვისიდან სერვისზე ინტერაქციისთვის. თუ მეტი გსურთ გაიგოთ, გირჩევთ წიგნს _REST in Practice_ (O’Reilly), სადაც REST over HTTP ღრმად არის განხილული.