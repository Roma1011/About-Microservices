განსაკუთრებით მიკროსერვისებზე დაფუძნებული არქიტექტურების შემთხვევაში, როდესაც თქვენი ფუნქციონალი გაყოფილია რამდენიმე დამოუკიდებელ სერვისზე, გამძლე სისტემის აგების აუცილებელი ნაწილია  **ფუნქციონალის უსაფრთხოდ დეგრადაციის უნარი**.

წარმოიდგინეთ ვებსაიტის სტანდარტული გვერდი ელექტრონული კომერციის პლატფორმაზე. ამ ვებსაიტის სხვადასხვა კომპონენტის ერთმანეთთან შესაკავშირებლად შეიძლება საჭირო გახდეს რამდენიმე მიკროსერვისი:

- ერთი მიკროსერვისი აჩვენებს ალბომის დეტალებს;
    
- მეორე  ფასსა და მარაგს;
    
- და სავაჭრო კალათაც, ალბათ, კიდევ ერთი მიკროსერვისია.
    

ახლა, თუ რომელიმე ამ სერვისთაგანი გამოვა მწყობრიდან და შედეგად მთელი ვებსაიტი მიუწვდომელი გახდება, მაშინ შეგვიძლია ვთქვათ, რომ შევქმენით სისტემა, რომელიც ნაკლებად გამძლეა, ვიდრე სისტემა, რომელსაც მხოლოდ ერთი ხელმისაწვდომი სერვისი სჭირდება.

ჩვენი მიზანია  **გავიგოთ თითოეული გათიშვის გავლენა და სწორად დეგრადირდეს ფუნქციონალი**.  

მაგალითად, თუ სავაჭრო კალათის სერვისი მიუწვდომელია, საქმე ცუდადაა, მაგრამ მაინც შეგვიძლია ვაჩვენოთ პროდუქტის გვერდი. შეიძლება უბრალოდ დავმალოთ კალათა ან ჩავანაცვლოთ ტექსტით „დაბრუნდება მალე!“

**მონოლითურ სისტემებში** ბევრი არჩევანი არ გვაქვს სისტემა ან მუშაობს, ან არა.  
**მიკროსერვისებში** კი საქმე უფრო დახვეწილადაა თითოეული გათიშვის შემთხვევაში უნდა გავიგოთ, რა უნდა მოვიმოქმედოთ. და ეს ყოველთვის ტექნიკური გადაწყვეტილება არ არის.

მაგალითად, როდესაც კალათის სერვისი არ მუშაობს:

- უნდა დავხუროთ მთელი საიტი?
    
- მივცეთ მომხმარებლებს უფლება დაათვალიერონ პროდუქტები?
    
- ჩავანაცვლოთ კალათის UI კომპონენტი სატელეფონო ნომრით, რომლითაც შეკვეთა შეიძლება?
    

ნებისმიერ მომხმარებელზე ორიენტირებულ ინტერფეისში, რომელიც ერთზე მეტ მიკროსერვისზეა დამოკიდებული, ან მიკროსერვისში, რომელსაც ქვემდგომი სერვისები აქვს, უნდა დაუსვათ საკუთარ თავს კითხვა:  
**„რა მოხდება, თუ ეს სერვისი არ იმუშავებს?“** და ზუსტად იცოდეთ, რა ქმედებაა საჭირო.

---

### **კრიტიკულობის გააზრება და არქიტექტურული უსაფრთხოების ზომები**

როდესაც გაიაზრებთ თქვენი შესაძლებლობების კრიტიკულობას ჯვარედინი ფუნქციური მოთხოვნების კონტექსტში (მაგ. ხელმისაწვდომობა, რეაგირების დრო და სხვა), უკეთ შეძლებთ სწორი გადაწყვეტილებების მიღებას.

#### ტექნიკური თვალსაზრისით, ფუნქციონალის ეტაპობრივი შემცირების საშუალებას გვაძლევენ არქიტექტურული უსაფრთხოების მექანიზმები, რაც უზრუნველყოფს, რომ სისტემის ერთი ნაწილის მარცხმა არ დაანგრიოს მთლიანი სისტემა.

ამის წინ, მოდი, ერთი რეალური შემთხვევა გაგიზიაროთ:
### **რეალური მაგალითი: როგორ გაგვაქრო პატარა მარცხმა მთელი სისტემა**

ერთ პროექტზე ტექნიკურ ლიდერად ვმუშაობდი ვქმნიდით ონლაინ განცხადებების ვებსაიტს. საიტს საკმაოდ მაღალი ტრაფიკი ჰქონდა და ბიზნესისთვის მნიშვნელოვან შემოსავალს წარმოადგენდა.  
ჩვენი ძირითადი აპლიკაცია ნაწილობრივ თავად აჩვენებდა განცხადებებს, ნაწილობრივ კი მიმართავდა სხვა სერვისებს, რომლებიც სხვადასხვა პროდუქტს ემსახურებოდნენ.

ეს ფაქტობრივად იყო **„strangler“ არქიტექტურა**, სადაც ახალი სისტემა თანდათანობით ცვლის ძველს.  
ჩვენ გადავიყვანეთ ყველაზე პოპულარული პროდუქტი ახალ სისტემაზე, მაგრამ დარჩენილი განცხადებების უმეტესობა ჯერ კიდევ ძველ სერვერებზე იყო.

სისტემა რამდენიმე ხანია რაც ფუნქციონირებდა და კარგად უმკლავდებოდა ტვირთს პიკის საათში 6000-7000 მოთხოვნას წამში.  
პროდუქტების ძიება უმეტესად ქეშში არ ინახებოდა და საჭიროებდა სრულ სერვერულ დამუშავებას.

ერთ დილით, პიკამდე ცოტა ხნით ადრე, სისტემა შენელდა და შემდეგ საერთოდ გაითიშა.

გამოვავლინეთ, რომ პრობლემა ერთ ქვემდგომ ძველ სერვისში იყო ძალიან ნელა რეაგირებდა. 

![[Pasted image 20250919232623.png]]
#### ფიგურა 11-1 

**ნელი რეაგირება ყველაზე რთული მარცხია.**  
თუ სერვისი საერთოდ არ მუშაობს, ამას სწრაფად მიხვდებით.  
მაგრამ როცა პასუხი იგვიანებს, სისტემა უბრალოდ "იცდის" და არც ერთ სერვისს არ შეუძლია იმუშაოს.

ჩვენი HTTP connection pool-ს ჰქონდა timeout-ები, რაც კარგია. მაგრამ პრობლემა იმაში იყო, რომ:

- სერვისები ითმენდნენ დიდხანს პასუხის მოლოდინს;
    
- ეს აჩერებდა სამუშაო ნაკადებს;
    
- თავისუფალი worker-ები არ იყო;
    
- ახალ მოთხოვნებს აღარ ჰქონდა რესურსი და ისინიც ვერ მუშავდებოდნენ;
    
- რაც კი იყო, ყველაფერი გაიჭედა.
    

პიკის დროს, როცა ნორმალურად 40 კავშირი გვქონდა, ამან წარმოშვა **800 კავშირის დატვირთვა**, რამაც სრულიად ჩამოანგრია სისტემა.

უფრო უარესი ის იყო, რომ ეს კონკრეტული სერვისი მთლიანად პლატფორმის მომხმარებლების 5%-ზე ნაკლებზე მოქმედებდა და შემოსავლის მხრივ კიდევ ნაკლებად.

---

### **რა ვისწავლეთ ამ მაგალითიდან:**

1. **ნელი სისტემები უარესია, ვიდრე გათიშულები** latency კლავს.
    
2. **უნდა გვქონდეს timeout-ები ყველგან  სწორად კონფიგურირებული.**
    
3. **ერთდროულად გამოყენებული კავშირების გაყოფა (bulkheading)** აუცილებელია.
    
4. **Circuit breaker-ის** გამოყენება სავალდებულოა, რომ ავირიდოთ ლეგასი სერვისთან მუდმივი მცდელობები.