ერთად შეკრება და შეთანხმება, თუ როგორ უნდა შესრულდეს საქმეები, კარგი იდეაა. მაგრამ ნაკლებად სასიამოვნოა დროის დახარჯვა იმის შესამოწმებლად, რომ ადამიანები ასრულებენ ამ მითითებებს, ან დეველოპერებისთვის დატვირთვის მოხვევა ყველა იმ სტანდარტული ფუნქციის განხორციელების მიზნით, რაც თითოეულ სერვისს უნდა ჰქონდეს.

მე მჯერა, რომ სწორი საქმის კეთება უნდა იყოს მარტივი. ორი მეთოდი, რომელიც კარგად მუშაობს: _exemplars_ (წარმატებული მაგალითები) და სერვისის შაბლონების (service templates) მიწოდება.

---

### Exemplars (წარმატებული მაგალითები)

დოკუმენტაცია კარგია და გამოსადეგი, და მეც ვხედავ მის ღირებულებას ბოლოსდაბოლოს, მეც ვწერ ამ წიგნს. მაგრამ დეველოპერებს ასევე უყვართ კოდი, რომელსაც შეუძლიათ გაშვება და გამოკვლევა.

თუ გაქვთ სტანდარტების ან საუკეთესო პრაქტიკების ნაკრები, რომელიც გსურთ, რომ გაიზარდოს, _exemplars_ ძალიან გამოსადეგია. იდეა ასეთია: ადამიანები მცირე შეცდომებსაც ვერ უშვებენ, თუ მათ სჯერდებიან სისტემის უკეთ ნაწილებს.

იდეალურად, ეს უნდა იყოს რეალური სერვისები, რომლებიც უკვე სწორად მუშაობენ, არა მარტო იდეალური, უბრალოდ მაგალითისთვის შექმნილი სერვისები. ამით უზრუნველყოფთ, რომ ყველა პრინციპი, რაც გაქვთ, რეალურად მუშაობს.

---

### Tailored Service Template (შენობისთვის მორგებული სერვისის შაბლონი)

როგორ მოგეწონებოდათ, რომ დეველოპერებისთვის ყველა მითითების დაცვა ძალიან მარტივი ყოფილიყო, თითქმის სავალდებულო ძალისხმევის გარეშე?

რა მოხდება, თუ დეველოპერებს უკვე აქვთ ძირითად სერვისს შემადგენელი კოდი, რომელიც უზრუნველყოფს თითოეული სერვისის ძირითადი ატრიბუტების განხორციელებას?

**Dropwizard** და **Karyon** არის ორი ღია წყარო, JVM-ზე დაფუძნებული მიკროკონტეინერი. ისინი მუშაობენ მსგავსი გზებით, ერთი კორპუსის ბიბლიოთეკების მეშვეობით უზრუნველყოფენ ფუნქციებს, როგორიცაა ჯანმრთელობის შემოწმება, HTTP სერვისი ან მეტრიკების გამოქვეყნება.

ამის შედეგად, გარედანვე შეგიძლიათ სერვისი embedded servlet container-ით, რომელიც შეგიძლიათ ბრძანების ხაზიდან აამუშავოთ. ეს შესანიშნავი დაწყების გზაა, მაგრამ რატომ უნდა შევჩერდეთ აქ?

- მაგალითად, შეგიძლიათ მოითხოვოთ circuit breakers-ის გამოყენება. ამ შემთხვევაში, შეიძლება ინტეგრირდეს ბიბლიოთეკა, როგორიცაა **Hystrix**.
    
- ან, შეიძლება მოთხოვნა იყოს, რომ ყველა მეტრიკა ცენტრალურ Graphite სერვერზე გაგზავნოთ. ამ შემთხვევაში, შეგიძლიათ გამოიყენოთ Dropwizard Metrics და კონფიგურაცია ისე, რომ response times და error rates ავტომატურად იგზავნოს.
    

სერვისის შაბლონის მორგება თქვენი განვითარების პრაქტიკებზე უზრუნველყოფს, რომ გუნდები სწრაფად დაიწყებენ მუშაობას და დეველოპერებმა სირთულეების შექმნა თავიდან აირიდონ.

---

თუ embraced გაქვთ სხვადასხვა ტექნოლოგიური სტეკები, საჭირო იქნება თითოეულისთვის შესაბამისი სერვისის შაბლონი. ეს შეიძლება subtle გზა იყოს ენის არჩევის შეზღუდვისთვის. მაგალითად, თუ შაბლონი მხოლოდ Java-ს მხარს უჭერს, ადამიანები შეიძლება აირიდონ სხვა სტეკებს, რადგან დამატებითი სამუშაო მათ სჭირდებათ.

Netflix-ს, მაგალითად, ძალიან აინტერესებს fault tolerance. დიდი სამუშაოა გაწეული იმისთვის, რომ გუნდებს ჰქონდეთ საჭირო ინსტრუმენტები, რომ სერვისები კარგად ფუნქციონირებდეს. ახალი ტექნოლოგიური სტეკის დანერგვა მოითხოვს ამ ძალისხმევის გამეორებას.

Netflix ამას იყენებს sidecar services-ის მეშვეობით, რომლებიც ლოკალურად ურთიერთქმედებენ JVM-თან, საჭირო ბიბლიოთეკებით.

---

სიფრთხილით მოეკიდოთ, რომ სერვისის შაბლონის შექმნა არ გახდეს ცენტრალური tools ან არქიტექტურის გუნდის სამუშაო, რომელიც „კოდის მეშვეობით“ უკარნახებს, როგორ უნდა გაკეთდეს ყველაფერი.

პრაქტიკების განსაზღვრა უნდა იყოს კოლექტიური აქტივობა იდეალურად, თქვენი გუნდი ერთად განაგებს შაბლონის განახლებას (შიდა ღია წყაროს მიდგომა კარგია).

გუნდის მორალი და პროდუქტიულობა ხშირად განადგურდა, როდესაც მათ თავს დაადეს სავალდებულო framework. კოდის ხელახალი გამოყენების მიზნით, სამუშაო ცენტრალიზდება და საბოლოოდ ეს ხდება უზარმაზარი მონსტრი.

თუ გადაწყვეტთ Tailored Service Template-ის გამოყენებას, ყურადღებით განსაზღვრეთ მისი მიზანი. იდეალურ შემთხვევაში, მისი გამოყენება უნდა იყოს ნებაყოფლობითი. თუ უფრო სავალდებულო ხდის adopt-ს, აუცილებელია გაითვალისწინოთ, რომ ease of use დეველოპერებისთვის უნდა იყოს მთავარი გზამკვლევი.

ასევე გონივრულად მოეკიდეთ shared code-ს. reusable კოდის შექმნის სურვილში, შესაძლოა სერვისებს შორის coupling გამოიწვიოთ. ზოგი ორგანიზაცია იმდენად ფიქრობს ამას, რომ service template-ის კოდს ხელით ასლის თითოეულ სერვისში. ეს უფრო ნელა განახორციელებს განახლებებს, მაგრამ უკეთესია, ვიდრე coupling-ის რისკი. სხვა გუნდები treat-ებენ service template-ს როგორც shared binary dependency, მაგრამ ყურადღებით უნდა იყვნენ, რომ DRY პრინციპი სისტემას არ აერთიანებდეს ზედმეტად.


შემდეგი [[ტექნიკური ვალი]]