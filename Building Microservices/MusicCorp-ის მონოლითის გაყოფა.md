წარმოიდგინეთ დიდი **ბექენდ მონოლითური სერვისი**, რომელიც მოიცავს MusicCorp-ის ონლაინ სისტემების მნიშვნელოვან ნაწილს.

1.  განვიხილოთ მაღალი დონის **bounded context-ები**, როგორც ეს თავი 3-ში გავაკეთეთ:
    
    - **Catalog** – ყველაფერი, რაც გაყიდვადი ნივთების **მეტადატას** (დასახელებები, აღწერები, ფასები და ა.შ.) ეხება.
        
    - **Finance** – ანგარიშგებები, გადახდები, დაბრუნებები და სხვა ფინანსური ოპერაციები.
        
    - **Warehouse** – შეკვეთების გაგზავნა და დაბრუნება, მარაგის აღრიცხვა და მართვა.
        
    - **Recommendation** – კომპლექსური რეკომენდაციის სისტემა, რომლის ალგორითმი სპეციალისტებთან ერთად შექმნილ კოდზეა დაფუძნებული.
        
2. თითოეული კონტექსტისთვის ვქმნით შესაბამის **პაკეტებს** და იქ გადაგვაქვს არსებული კოდი. თანამედროვე IDE-ები საშუალებას გვაძლევს კოდი ავტომატურად და თანმიმდევრულად გადავანაწილოთ, სხვა პროცესების პარალელურად.
    
3. **ტესტები** აუცილებელია შეცდომების დროულად დასაფიქსირებლად, განსაკუთრებით დინამიკურად ტიპირებულ ენებში, სადაც IDE-ის Refactoring უფრო რთულია.
    
4. პროცესი გვაჩვენებს, რომელი კოდი **კარგად ჯდება** თავის კონტექსტში და რომელი **გამოყოფას საჭიროებს**. დარჩენილი „დაუმორჩილებელი“ კოდი ხშირად მიგვითითებს ჯერ კიდევ გამოსაყოფ **bounded context-ებზე**.
    
5. კოდის ანალიზისთვის შეგვიძლია გამოვიყენოთ ინსტრუმენტები, მაგალითად **Structure 101**, რათა ვიზუალურად დავინახოთ პაკეტებს შორის დამოკიდებულებები.
    
    - თუ აღმოჩნდება, რომ, მაგალითად, **Warehouse პაკეტი** დამოკიდებულია **Finance პაკეტზე**, მაშინ როცა ასეთი კავშირი ლოგიკურად არ უნდა არსებობდეს, ამას ვიკვლევთ და ვასწორებთ.
        
6. დროის ხარჯი: მცირე კოდის ბაზისთვის ეს პროცესი შეიძლება რამდენიმე საათი გაგრძელდეს, ხოლო მილიონი ხაზის კოდისთვის რამდენიმე კვირა ან თვე.
    
    - პირველი სერვისის გამოყოფისას ყველა კოდის სრული დომენური დაყოფა სავალდებულო არ არის  ეს შეიძლება ნელ-ნელა, ეტაპობრივად, ყოველდღიურად მოხდეს.