წარმოიდგინეთ დიდი **backend მონოლითური სერვისი**, რომელიც წარმოადგენს MusicCorp-ის ონლაინ სისტემების დიდ ნაწილს.

1. ვამოიცნობთ მაღალ დონის **bounded contexts**-ებს, როგორც ეს თავი 3-ში გავაკეთეთ.
    
    - **Catalog** – ყველაფერი, რაც დაკავშირებულია გაყიდვის ნივთების მეტადატასთან.
        
    - **Finance** – ანგარიშგებები, გადახდები, დაბრუნებები და ა.შ.
        
    - **Warehouse** – შეკვეთების გაგზავნა და დაბრუნება, მარაგის მართვა.
        
    - **Recommendation** – კომპლექსური რეკომენდაციული სისტემა, რომელიც პედაგოგებთან გადამუშავებული კოდით არის შექმნილი.
        
2. ვქმნით **პაკეტებს** ამ კონტექსტებისთვის და ვმოძრავებთ იქ არსებული კოდს. თანამედროვე IDE-ები საშუალებას გვაძლევს **ავტომატურად გადავიტანოთ კოდი**, თანაც თანმიმდევრულად, სხვა პროცესების პარალელურად.
    
3. **ტესტები** აუცილებელია ნებისმიერი შეცდომის მისაღებად, განსაკუთრებით დინამიურად ტიპირებული ენების შემთხვევაში, სადაც IDE-ს Refactoring-ს შესრულება რთულია.
    
4. პროცესი გვაჩვენებს, რა კოდი **კარგად ემთხვევა** კონტექსტს და რა კოდი **ჩაკლია** — ხშირად დარჩენილი კოდი გვიჩვენებს გადარჩენილ **bounded contexts-ებს**, რომელთა მიყვანაც დაგვრჩა.
    
5. კოდის ანალიზი: შეგვიძლია გამოვიყენოთ ინსტრუმენტები, როგორიცაა **Structure 101**, რომ ვნახოთ პაკეტებს შორის დამოკიდებულებები გრაფიკულად.
    
    - თუ ვხედავთ, რომ მაგალითად **warehouse პაკეტი** დამოკიდებულია **finance პაკეტზე**, როცა რეალურად ასეთი დამოკიდებულება არ არსებობს, პრობლემას ვიკვლევთ და ვასწორებთ.
        
6. დროის ჩართულობა: მცირე კოდის ბაზისთვის ეს შეიძლება რამდენიმე საათი იყოს, მილიონ ხაზიან კოდზე კი რამდენიმე კვირა ან თვე.
    
    - პირველი სერვისის გამოყოფისთვის ყველა კოდის დომენზე დაყოფა აუცილებელი არ არის — შესაძლებელია ნელ-ნელა, ნაბიჯ-ნაბიჯ, დღიდან დღემდე.