დეველოპერებს ხშირად გვესმის აკრონიმი **DRY** — _Don’t Repeat Yourself_ („ნუ გაიმეორებ თავს“).  
ხშირად მას ამარტივებენ, როგორც კოდის დუბლირების თავიდან აცილებას, მაგრამ უფრო ზუსტი მნიშვნელობაა სისტემის ქცევისა და ცოდნის დუბლირების თავიდან აცილება.

ზოგადად ეს ძალიან გონივრული რჩევაა. ბევრი სტრიქონი, რომელიც ერთსა და იმავე საქმეს აკეთებს, კოდის ბაზას ზომაში ზრდის და ართულებს მის გააზრებას.  
თუ ქცევა, რომლის შეცვლაც გსურთ, ბევრ ადგილას არის დუბლირებული, მარტივად შეიძლება გამოგრჩეთ ყველა ადგილი და შედეგად ბაგები გაჩნდეს.

ამიტომაც DRY-ის დაცვა როგორც მანტრა ზოგადად სწორი მიდგომაა.

DRY სწორედ ის მიზეზია, რის გამოც ვქმნით ხელახლა გამოსაყენებელ კოდს: დუბლირებული ლოგიკის ამოღება აბსტრაქციებში და მისი გამოყენება მრავალ ადგილას.  
ზოგჯერ კი ამას ვააღრმავებთ და ვქმნით საერთო ბიბლიოთეკასაც, რომელიც ყველგან შეიძლება გამოვიყენოთ.

მაგრამ ეს მიდგომა **მიკროსერვისულ არქიტექტურაში მოტყუებით საშიშია**.

მიკროსერვისში ერთ-ერთი ყველაზე საშიში რამ არის მისი ზედმეტი მიბმა მომხმარებლებზე ისე, რომ სერვისის მცირე ცვლილებამაც კი გამოიწვიოს არასაჭირო ცვლილებები მომხმარებლებში.

ზოგჯერ სწორედ გაზიარებული კოდი ქმნის ასეთ მიბმას.

მაგალითად, ერთ პროექტში გვქონდა საერთო დომენური ობიექტების ბიბლიოთეკა, რომელიც ჩვენს სისტემაში არსებულ ძირითად ერთეულებს წარმოადგენდა.  
ეს ბიბლიოთეკა ყველა სერვისს იყენებდა. მაგრამ მასში ცვლილების შეტანისას ყველა სერვისის განახლება გვიწევდა. ჩვენი სისტემა მესიჯ-ქიუებზე მუშაობდა, ამიტომ მათი გაწმენდაც გვიწევდა, წინააღმდეგ შემთხვევაში ძველი მონაცემები არასწორად მუშაობდა და ღმერთმა ნუ ქნას, თუ ეს დაგავიწყდებოდა.

თუ გაზიარებული კოდი სერვისის საზღვრებს გარეთ აღწევს, თქვენ ქმნით მიბმის ფორმას.

**შიგნით გაზიარებული კოდი ნორმალურია**  მაგალითად ლოგირების ბიბლიოთეკები, რადგან ისინი სერვისის გარეთ არ ჩანს.

მაგალითად, _RealEstate.com.au_ ახალ სერვისებზე მუშაობის დასაწყებად იყენებს სპეციალურ შაბლონს. მაგრამ მის გაზიარებას არ აკეთებს ახალ სერვისზე კოპირებას ანიჭებს უპირატესობას, რათა თავიდან აიცილოს კავშირის გაჟონვა.

ჩემი **წესი** ასეთია:

- მიკროსერვისის შიგნით ნუ დაარღვევთ DRY-ს.
    
- მაგრამ სერვისებს შორის იყავით მოქნილი და დარღვიეთ DRY, თუ საჭიროა.
    

სერვისებს შორის ზედმეტი მიბმის საფრთხე ბევრად უარესია, ვიდრე კოდის დუბლირების პრობლემა.

## Client Libraries

მრავალ გუნდს შევხვედრილვარ, რომლებიც თვლიან, რომ სერვისებისთვის **client library**-ების შექმნა აუცილებელია. არგუმენტი ასეთია: ეს აადვილებს სერვისის მოხმარებას და თავიდან იცილებს სერვისზე გამოძახებისას კოდის დუბლირებას.

პრობლემა ისაა, რომ თუ სერვერის API-ს და client API-ს ერთნაირი გუნდი წერს, არსებობს საფრთხე, რომ ის ლოგიკა, რაც მხოლოდ სერვერზე უნდა იყოს, ნელ-ნელა კლიენტში გადავა.

ეს თავადაც გამიკეთებია  და რაც უფრო მეტი ლოგიკა გადადის client library-ში, მით უფრო ირღვევა კოჰეზია: fixes-ისთვის სერვერზე ცვლილების შეტანისას კლიენტების შეცვლაც გიწევს.

ასევე ზღუდავ ტექნოლოგიურ არჩევანს, განსაკუთრებით თუ client library-ს სავალდებულოდ იყენებ.

**Amazon Web Services (AWS)** საინტერესო მოდელს გვთავაზობს: underlying REST ან SOAP API პირდაპირაც შეგიძლია გამოიყენო, მაგრამ ჩვეულებრივ, ყველანი ერთ-ერთ SDK-ს იყენებენ, რომლებიც ამ API-ზე აბსტრაქციებს აკეთებენ.

ეს SDK-ები ან საზოგადოებას აქვს დაწერილი, ან AWS-ის სხვა გუნდებს (არა API-ს ავტორებს).  
ეს გამიჯვნა კარგად მუშაობს და თავიდან გვაცილებს პრობლემებს.  
ამასთან, კლიენტი თავად წყვეტს როდის განაახლოს საკუთარი ბიბლიოთეკა  რაც ძალიან მნიშვნელოვანია.

**Netflix** კი დიდ მნიშვნელობას ანიჭებს client library-ს. მაგრამ აქაც მთავარი არაა კოდის დუბლირების თავიდან აცილება.

Netflix-ის client library-ები ასევე უზრუნველყოფს:

- სერვისის აღმოჩენას
    
- ავარიის რეჟიმების მართვას
    
- ლოგირებას
    
- მასშტაბურობაზე გათვლილ სხვა ფუნქციონალს
    

ანუ ისინი სერვისის თვითონ ბუნებას არ ეხება.

ამ ბიბლიოთეკების გარეშე Netflix-ს გაუჭირდებოდა მასშტაბურობის პირობებში საიმედო კლიენტ-სერვერის კომუნიკაციის უზრუნველყოფა.

ეს გაზარდა პროდუქტიულობა და გაამარტივა სტარტი, მაგრამ, როგორც მინიმუმ Netflix-ის ერთმა ინჟინერმა თქვა, დროთა განმავლობაში კლიენტსა და სერვერს შორის გარკვეული პრობლემური მიბმა მაინც გაჩნდა.

თუ **client library**-ს შექმნას აპირებთ, გაითვალისწინეთ:

- გამოყავით ტრანსპორტის პროტოკოლის დამმუშავებელი კოდი (service discovery, failure handling…) იმ კოდიდან, რომელიც კონკრეტულ სერვისს ეხება.
    
- გადაწყვიტეთ — სავალდებულო იქნება თუ არა მისი გამოყენება.
    
- და აუცილებლად უზრუნველყავით, რომ **კლიენტი თვითონ წყვეტდეს, როდის განაახლოს** ბიბლიოთეკა.
    

ეს აუცილებელია იმისათვის, რომ შევინარჩუნოთ სერვისების დამოუკიდებელი გამოშვების უნარი.