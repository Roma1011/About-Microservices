ჩვენ მომხმარებლის ინტერფეისის სამყაროს საერთოდ არ შევხებივართ. თქვენ ზოგიერთმა შეიძლება მხოლოდ ცივი, მკაცრი, „კლინიკური“ API მიაწოდოთ თქვენს მომხმარებლებს, მაგრამ ჩვენ ბევრს გვიწევს ისეთი ლამაზი, ფუნქციონალური მომხმარებლის ინტერფეისების შექმნა, რომლებიც გაახარებენ ჩვენს მომხმარებლებს. თუმცა, ნამდვილად საჭიროა მათზე ინტეგრაციის კონტექსტში ფიქრი. ბოლოს და ბოლოს, მომხმარებლის ინტერფეისი ის ადგილია, სადაც ჩვენ ყველა ამ მიკროსერვისს ერთ მთლიანობაში ვაქსოვთ, რათა ჩვენს მომხმარებლებს აზრი ჰქონდეს.

წარსულში, როცა პირველად დავიწყე კომპიუტერებთან მუშაობა, ძირითადად ვსაუბრობდით დიდ, „მსუქან“ კლიენტებზე, რომლებიც ჩვენს დესკტოპებზე მუშაობდნენ. ბევრი საათი დამიხარჯავს Motif-თან და შემდეგ Swing-თან მუშაობაში, იმის მცდელობით, რომ ჩემი პროგრამული უზრუნველყოფა სასიამოვნო ყოფილიყო. ხშირად ეს სისტემები მხოლოდ ლოკალური ფაილების შექმნასა და მართვას ემსახურებოდა, მაგრამ ბევრს სერვერის მხარესაც ჰქონდა კომპონენტები. ThoughtWorks-ში ჩემი პირველი სამსახური Swing-ზე დაფუძნებული ელექტრონული გაყიდვების წერტილის სისტემის შექმნა იყო, რომელიც მხოლოდ დიდი სისტემის ერთ ნაწილს წარმოადგენდა, რომლის უმეტესობა სერვერზე იყო.

შემდეგ მოვიდა ვებ. ჩვენ დავიწყეთ ფიქრი, რომ UI უფრო „თხელი“ უნდა ყოფილიყო, მეტი ლოგიკით სერვერის მხარეს. დასაწყისში ჩვენი სერვერული პროგრამები მთლიან გვერდს ქმნიდა და მომხმარებლის ბრაუზერს უგზავნიდა, რომელიც თითქმის არაფერს აკეთებდა. ნებისმიერი ინტერაქცია სერვერზე მუშავდებოდა GET და POST მოთხოვნებით, რომლებიც მომხმარებლის ბმულებზე დაჭერით ან ფორმების შევსებით ირთვებოდა.

დროთა განმავლობაში, JavaScript უფრო პოპულარული გახდა, როგორც საშუალება, ბრაუზერში დინამიური ქცევა დაგვემატებინა, და ზოგიერთი აპლიკაცია შეიძლება იმდენად „მსუქანი“ გამხდარიყო, როგორც ძველი დესკტოპ აპლიკაციები.


### ციფრულისკენ

ბოლო რამდენიმე წლის განმავლობაში, ორგანიზაციებმა დაიწყეს დაშორება იმ იდეიდან, რომ ვებსა და მობილურს ცალ-ცალკე უნდა ვექცეოდეთ; ახლა მათ „ციფრულზე“ უფრო ჰოლისტურად ფიქრი დაიწყეს. რა არის საუკეთესო გზა, რომლითაც ჩვენს მომხმარებლებს შეუძლიათ ისარგებლონ ჩვენი სერვისებით? და ეს რას აკეთებს ჩვენი სისტემის არქიტექტურისთვის? ის გაცნობიერება, რომ ჩვენ ვერ ვიწინასწარმეტყველებთ, ზუსტად როგორ იმოქმედებს მომხმარებელი ჩვენს კომპანიასთან, გახდა უფრო წვრილმანი API-ების, მაგალითად მიკროსერვისების, მიღების მამოძრავებელი ძალა. ჩვენი სერვისების შესაძლებლობების სხვადასხვა გზით კომბინირებით, შეგვიძლია ჩვენი მომხმარებლებისთვის სხვადასხვა გამოცდილების მოზიდვა იქნება ეს დესკტოპ აპლიკაციაზე, მობილურ მოწყობილობაზე, სმარტ-საათზე თუ ფიზიკურ სივრცეში, როცა ისინი ჩვენს მაღაზიაში მოდიან.

მომხმარებლის ინტერფეისებზე იფიქრეთ, როგორც კომპოზიციურ ფენებზე — ადგილებად, სადაც ჩვენ ვქსოვთ შესაძლებლობების სხვადასხვა ძაფს. ამ გათვალისწინებით, როგორ უნდა მოვქსოვოთ ყველა ეს ძაფი ერთად?

### შეზღუდვები

შეზღუდვები არის სხვადასხვა ფორმა, რომლითაც მომხმარებლები ჩვენს სისტემასთან ურთიერთობენ. მაგალითად, დესკტოპის ვებ-აპლიკაციაზე ჩვენ ვითვალისწინებთ შეზღუდვებს, როგორიცაა რომელი ბრაუზერით სარგებლობს მომხმარებელი ან რა რეზოლუცია აქვს. მაგრამ მობილურმა სრულიად ახალი შეზღუდვები შემოიტანა.

ის, თუ როგორ ურთიერთობენ ჩვენი მობილური აპლიკაციები სერვერთან, შეიძლება მნიშვნელოვან გავლენას ახდენდეს. საქმე მხოლოდ გამტარუნარიანობას კი არ ეხება  სადაც მობილური ქსელების ლიმიტებს შეუძლია როლი ითამაშოს. სხვადასხვა სახის ინტერაქციებს შეუძლია ბატარეის სწრაფად დამუხტვა, რაც კლიენტების გაღიზიანებას იწვევს.

ინტერაქციების ბუნებაც იცვლება. ტაბლეტზე ადვილად ვერ დავაწვები მარჯვენა ღილაკს. მობილურ ტელეფონზე შესაძლოა ინტერფეისის ისე დიზაინი მომინდეს, რომ ერთი ხელით, ძირითადად ცერით იყოს მოსახმარი. სხვაგან შეიძლება SMS-ის საშუალებით მივცე მომხმარებლებს სერვისებთან ურთიერთობის საშუალება, სადაც გამტარუნარიანობა შეზღუდულია — მაგალითად, გლობალურ სამხრეთში SMS-ის როგორც ინტერფეისის გამოყენება უზარმაზარია.

ამიტომ, მიუხედავად იმისა, რომ ჩვენი ძირითადი სერვისები — ჩვენი ძირითადი შეთავაზება — იგივე რჩება, ჩვენ გვჭირდება გზა, რომ ისინი სხვადასხვა ინტერფეისის შეზღუდვებზე მოვარგოთ. როცა მომხმარებლის ინტერფეისის სხვადასხვა სტილს განვიხილავთ, უნდა დავრწმუნდეთ, რომ ისინი ამ გამოწვევას პასუხობენ. მოდით ვნახოთ რამდენიმე მოდელი, თუ როგორ შეიძლება ამის მიღწევა.


### API კომპოზიცია

ვთქვათ, ჩვენი სერვისები უკვე ურთიერთობენ ერთმანეთთან XML-ით ან JSON-ით HTTP-ზე. მაშინ, ცხადი არჩევანია, რომ ჩვენი UI პირდაპირ ამ API-ებთან ურთიერთობდეს, როგორც ნაჩვენებია ფიგურა 4-7. ვებ-ინტერფეისი შეიძლება გამოიყენებდეს JavaScript GET მოთხოვნებს მონაცემების წამოსაღებად, ან POST მოთხოვნებს მათი შესაცვლელად. ნატიური მობილური აპლიკაციებისთვისაც HTTP კომუნიკაციის ინიციირება საკმაოდ მარტივია. UI-ს შემდეგ მოუწევს ინტერფეისის კომპონენტების შექმნა, სერვერთან მდგომარეობის სინქრონიზაცია და მსგავსი საკითხები. თუ სერვისებს შორის კომუნიკაციისთვის ბინარული პროტოკოლი გვექნებოდა, ეს უფრო რთული იქნებოდა ვებ-კლიენტებისთვის, თუმცა ნატიური მობილური მოწყობილობებისთვის ნორმალური.

ამ მიდგომას რამდენიმე უარყოფითი მხარეც აქვს. პირველ რიგში, ჩვენ ნაკლები შესაძლებლობა გვაქვს, რომ პასუხები სხვადასხვა მოწყობილობისთვის მოვარგოთ. მაგალითად, როცა მომხმარებლის ჩანაწერს ვიღებ, საჭიროა იგივე მონაცემები წამოვიღო მობილური მაღაზიისთვის, რაც ჰელპდესკის აპლიკაციისთვის? ამ მიდგომის ერთი გადაწყვეტაა, რომ მომხმარებლებს მივცეთ საშუალება მიუთითონ, რომელი ველები სურთ წამოიღონ მოთხოვნის დროს, მაგრამ ეს იმაზეა დამოკიდებული, თუ თითოეული სერვისი ასეთ ურთიერთქმედებას უჭერს მხარს.

სხვა მნიშვნელოვანი კითხვა: ვინ ქმნის მომხმარებლის ინტერფეისს? სერვისებზე პასუხისმგებელი ადამიანები მოშორებულნი არიან იმგან, თუ როგორ „სჩანს“ მათი სერვისი მომხმარებლებისთვის  მაგალითად, თუ სხვა გუნდი ქმნის UI-ს, შესაძლოა ისევ იმ ცუდ დროებში დავბრუნდეთ, როცა ფენური არქიტექტურა გვქონდა და მცირე ცვლილების განხორციელებასაც კი რამდენიმე გუნდთან ცვლილების მოთხოვნა სჭირდებოდა.
![[Pasted image 20250909140123.png]]
##### ფიგურა 4-7

ამ კომუნიკაციას ასევე შეუძლია საკმაოდ „ჭორიკანა“ (chatty) გამოდგეს. პირდაპირ ბევრი სერვისზე ზარის გახსნა მობილური მოწყობილობებისთვის ინტენსიური შეიძლება აღმოჩნდეს და მომხმარებლის მობილური გეგმის (data plan) ძალიან არაეფექტური გამოყენება გახდეს! აქ API gateway შეიძლება დაგვეხმაროს, რადგან შეგვიძლია ასეთი ზარები გავამზეუროთ, რომლებიც რამდენიმე ქვედა დონის ზარს აერთიანებენ, თუმცა ამასაც თავისი უარყოფითი მხარეები აქვს, რომელთა განხილვასაც მალე დავიწყებთ.



### UI ფრაგმენტების კომპოზიცია

მიკროსერვისებისგან შეიძლება არ გვინდა, რომ ჩვენი UI პირდაპირ API ზარებს აკეთებდეს და ყველაფერს UI კონტროლებში გადაიტანდეს; ამის ნაცვლად, ჩვენი სერვისები შეუძლიათ პირდაპირ UI-ს ფრაგმენტები უზრუნველყონ, რომლებიც შემდგომ მხოლოდ შეგროვდება მთლიან UI-ს შესაქმნელად, როგორც ნაჩვენებია სურათში 4-8.

მაგალითად, წარმოიდგინეთ, რომ რეკომენდაციების სერვისი უზრუნველყოფს რეკომენდაციების ვიჯეტს, რომელიც სხვა კონტროლებთან ან UI ფრაგმენტებთან ერთად გამოიყენება სრულ UI-ს შესაქმნელად. ეს შეიძლება გამოჩნდეს, როგორც ყუთი ვებ-გვერდზე სხვა კონტენტთან ერთად.

ამ მიდგომის ვარიანტი, რომელიც კარგად მუშაობს, არის უფრო „მოზრდილი“ UI-ფრაგმენტების სიმრავლე. ანუ, მცირე ვიჯეტების შექმნის ნაცვლად, მთელი პანელები ან გვერდების ნაკრები იგროვება thick client აპლიკაციისთვის ან ვებ-საიტისთვის.

ეს უფრო გრძელი ფრაგმენტები გამოისახება სერვერული აპლიკაციებიდან, რომლებიც შესაბამის API ზარებს ახორციელებენ. ეს მოდელი საუკეთესოდ მუშაობს მაშინ, როცა ფრაგმენტები კარგად ემთხვევა გუნდის პასუხისმგებლობას. მაგალითად, მუსიკალური მაღაზიის შეკვეთების მართვის გუნდი უზრუნველყოფს ყველა გვერდს, რომელიც დაკავშირებულია შეკვეთების მართვასთან.
![[Pasted image 20250909140434.png]]
##### სურათი 4-8. სერვისები პირდაპირ უზრუნველყოფენ UI კომპონენტებს შემკრებისთვის

თქვენ კვლავ გჭირდებათ ერთგვარი „საგრეგაციო“ ფენა, რომელიც ამ ნაწილებს ერთად მოაგროვებს. ეს შეიძლება იყოს მარტივი სერვერული ტემპლეტირება, ან, როცა თითოეული გვერდების ნაკრები სხვადასხვა აპლიკაციიდან მოდის, შეიძლება საჭირო გახდეს ჭკვიანი URI როუტინგი.

ამ მიდგომის ერთ-ერთი მთავარი უპირატესობა არის ის, რომ გუნდი, რომელიც ცვლილებებს აკეთებს სერვისებზე, ასევე პასუხისმგებელია UI-ის შესაბამისი ნაწილების ცვლილებებზე. ეს საშუალებას გვაძლევს ცვლილებები უფრო სწრაფად გამოვუშვათ. მაგრამ ამ მიდგომას გარკვეული პრობლემებიც ახლავს.

---

პირველი, მომხმარებლის გამოცდილების კონსისტენტურობის უზრუნველყოფა მნიშვნელოვანია. მომხმარებლები სურთ უწყვეტი გამოცდილება, რომ არ იგრძნონ, რომ ინტერფეისის სხვადასხვა ნაწილი განსხვავებულად მუშაობს ან განსხვავებულ დიზაინ ენას იყენებს. ამის შესაჩერებლად არსებობს ტექნიკები, მაგალითად living style guides, სადაც HTML კომპონენტები, CSS და სურათები შეიძლება გაიზიაროს კონსისტენტურობის შესანარჩუნებლად.

მეორე პრობლემა რთულად იხსნება. რა ხდება ნატიურ აპლიკაციებთან ან thick clients-თან? ჩვენ ვერ შევძლებთ UI კომპონენტების სერვირებას. შესაძლებელი ვარ ჰიბრიდული მიდგომა, სადაც ნატიურ აპლიკაციებს შევძლებთ HTML კომპონენტების სერვირებას, მაგრამ ეს მიდგომა ხშირად უარყოფით შედეგებს იძლევა. ამიტომ, თუ ნატიურ გამოცდილებაა საჭირო, უნდა დავუბრუნდეთ მიდგომას, სადაც frontend აპლიკაცია აკეთებს API ზარებს და თავად მართავს UI-ს.

თუნდაც ვებ-UI-ს შემთხვევაში, შესაძლოა გვსურს მოწყობილობის ტიპის მიხედვით სხვადასხვა მკურნალობა. რისპონსიული კომპონენტების აშენება, ბუნებრივია, ამაში დაგვეხმარება.

---

ერთი ძირითადი პრობლემა, რომელიც ამ მიდგომას აქვს და რომელიც, ვფიქრობ, ვერ გადაიჭრება, არის ის, რომ სერვისების შეთავაზებული შესაძლებლობები ყოველთვის ვერ ეტევა ვიჯეტში ან გვერდში. მაგალითად, შეიძლება მსურს რეკომენდაციების ჩვენება ვებ-გვერდზე ყუთში, მაგრამ როგორ შევიტანო დინამიური რეკომენდაციები სხვა ადგილას? როცა ვეძებ, მინდა type-ahead ავტომატურად გამოიწვიოს ახალი რეკომენდაციები. რაც უფრო „გადაკვეთა“ ტიპის ინტერაქციაა, მით უფრო ნაკლებად ერგება ეს მოდელი და უფრო მეტია შანსი, რომ ისევ API ზარების გამოყენების გზას დავუბრუნდეთ.


### Backends for Frontends (BFFs)

ჩვეულებრივი გადაწყვეტა „ჭორიკანა“ ინტერფეისების პრობლემაზე backend სერვისებთან ან საჭიროებაზე, რომ კონტენტი მოწყობილობის ტიპის მიხედვით შეიცვალოს, არის სერვერული აგრეგაციის endpoint ან API gateway. ეს საშუალებას აძლევს ერთიანად მართოს რამდენიმე backend ზარი, საჭიროების შემთხვევაში გააერთიანოს კონტენტი და გააცნოს მოწყობილობას, როგორც ნაჩვენებია სურათში 4-9.

მე ვნახე, რომ ეს მიდგომა ზოგჯერ კატასტროფამდე მიჰყავს, როცა სერვერული endpoints გადაჯაჭვავენ ზედმეტ ლოგიკას. ისინი იწყებენ სხვადასხვა გუნდების მიერ მართვას, რაც ქმნის კიდევ ერთ ადგილს, სადაც ლოგიკა უნდა შეიცვალოს ფუნქციონალის ცვლილებისას.

---
![[Pasted image 20250909144025.png]]
##### სურათი 4-9. ერთი მონოლითური gateway-ის გამოყენება UI ზარებისთვის

---

პრობლემა ისაა, რომ ჩვეულებრივ ერთ „გიგანტურ ფენას“ ვქმნით ყველა სერვისისთვის. ეს იწვევს ყველაფრის ერთად შეწყვეტას და იზოლაციის დაკარგვას UI-ებში, რაც აბრკოლებს მათ დამოუკიდებელ გამოშვებას.

მოდელი, რომელიც მირჩევნია და კარგად მუშაობს, არის BFF-ების გამოყენება კონკრეტული UI-სთვის ან აპლიკაციისთვის, როგორც ნაჩვენებია სურათში 4-10.

---
![[Pasted image 20250909144050.png]]
##### სურათი 4-10. კონკრეტული UI-სთვის სპეციალური backend-ის გამოყენება

---

ეს მექანიზმი ზოგჯერ ცნობილია როგორც **Backends for Frontends (BFFs)**. ის საშუალებას აძლევს გუნდს, რომელიც კონკრეტულ UI-ზე მუშაობს, ასევე მართოს საკუთარი სერვერული კომპონენტები. შეგიძლიათ წარმოიდგინოთ, რომ ეს BFF-ები UI-ის ნაწილი არიან, რომლებიც სერვერზე ინტეგრირებულია.

UI-ის ზოგი ტიპი შეიძლება საჭიროებდეს მინიმალურ სერვერულ footprint-ს, ხოლო სხვა შეიძლება ბევრად მეტი სერვერული მხარდაჭერა საჭიროებდეს. თუ საჭიროა API ავტენტიკაცია და ავტორიზაცია, ეს შეიძლება მოთავსდეს BFF-ებსა და UI-ს შორის. ამაზე უფრო დეტალურად ვისაუბრებთ თავში 9.

---

ამ მიდგომის საფრთხე იგივეა, რაც ნებისმიერი აგრეგაციის ფენის შემთხვევაში: ის შეიძლება მიიღოს ლოგიკა, რომელიც არ უნდა ჰქონდეს. სხვადასხვა შესაძლებლობის ბიზნეს-ლოგიკა უნდა დარჩეს სერვისებში. ეს BFF-ები უნდა შეიცავდეს მხოლოდ იმ ქცევას, რომელიც კონკრეტული მომხმარებლის გამოცდილების მიწოდებას ემსახურება.


### ჰიბრიდული მიდგომა

წინა ვარიანტების დიდი ნაწილი არ საჭიროებს “ერთი ზომა ყველასთვის” მიდგომას. წარმოვიდგინოთ ორგანიზაცია, რომელიც ვებსაიტის შექმნისას იყენებს ფრაგმენტებზე დაფუძნებულ ასამბლირების მიდგომას, ხოლო მობილური აპლიკაციის შემთხვევაში იყენებს **backends-for-frontends (BFF)** მიდგომას.

მნიშვნელოვანი მხარე ის არის, რომ ჩვენ უნდა შევინარჩუნოთ მთლიანობა (cohesion) იმ ძირითადი შესაძლებლობების, რასაც ვთავაზობთ მომხმარებლებს. უნდა დავრწმუნდეთ, რომ ლოგიკა, რომელიც უკავშირდება მუსიკის შეკვეთის პროცესს ან მომხმარებლის დეტალების ცვლილებას, დარჩეს იმ სერვისებში, რომლებიც ამ ოპერაციებს ასრულებენ და არ გავრცელდეს სისტემის სხვა ნაწილებში.

გადაჭარბებული ქცევის მოთავსებისაგან ნებისმიერი საშუალო ფენაში თავის დაღწევა რთული ბალანსირების აქტია.