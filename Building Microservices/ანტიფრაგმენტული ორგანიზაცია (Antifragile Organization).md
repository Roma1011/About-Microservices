Nassim Taleb-ის წიგნში _Antifragile_, განხილულია იდეა, რომ არსებობს სისტემები, რომლებიც მარცხით არათუ ზიანდებიან, არამედ **აძლიერებენ საკუთარ თავს**.

**Netflix-მა** ეს იდეა აიტაცა და გაატარა კონცეფცია: **„ანტიფრაგმენტული ორგანიზაცია“**

- Netflix მთლიანად მუშაობს AWS-ზე.
    
- იმის ნაცვლად, რომ თავიდან აიცილოს მარცხი, ის **სპეციალურად იწვევს მარცხს**, რომ დარწმუნდეს, შეუძლია მისი გადატანა.
    

მაგალითად:

- ზოგ კომპანიას აქვს **game day** — მარცხის სიმულაცია. Google-საც ასე ჰქონდა.
    
- Google იმიტირებდა მიწისძვრებს DiRT პროგრამით.
    
- Netflix კი ყოველდღე აწარმოებს პროგრამებს, რომლებიც მარცხს გამოიწვევს **პროდაქშენში**!
    

### ყველაზე ცნობილი მათგანია **Chaos Monkey**:

- გამორთავს შემთხვევით მანქანებს სამუშაო საათებში.
    
- ამის ცოდნა აიძულებს დეველოპერებს, დაწერონ კოდი, რომელიც გაუძლებს მარცხს.
    

Netflix-ის Simian Army მოიცავს სხვა „მონსტრებსაც“:

- **Chaos Gorilla** მთლიანი availability zone-ის გამოთიშვა;
    
- **Latency Monkey**  ქსელის დაგვიანების იმიტაცია.
    

ეს ინსტრუმენტები ღია ლიცენზიით ხელმისაწვდომია.

---

### **მთავარი გაკვეთილი:**

Netflix არამხოლოდ ავითარებს სისტემებს მარცხისთვის, არამედ **სწავლისა და პასუხისმგებლობის კულტურას**აც ფლობს:

- დეველოპერები თავად არიან პასუხისმგებელი თავიანთი სერვისების მუშაობაზე;
    
- მარცხისგან სწავლა პრიორიტეტულია, და **დამნაშავის ძებნა არაა მიზანი** — მნიშვნელოვანია, რას ვისწავლით.
    

---

### **შეჯამება:**

არ არის აუცილებელი extremes (Netflix, Google) დონეზე წასვლა,  
მაგრამ **მნიშვნელოვანია, რომ შეიცვალოს აზროვნება** 
**დისტრიბუტირებულ სისტემებში მარცხი გარდაუვალია**.

- ქსელი არასაიმედოა.
    
- აპარატურა გაფუჭდება.
    
- სერვისები დაიწვება.
    

ამიტომ საჭიროა:

- სისტემები, რომლებიც **ელიან მარცხს**,
    
- და **აღდგებიან graceful გზით**, როცა ის მოხდება.


---

### Timeout-ები (დაყოვნების ლიმიტები)

**Timeout-ები ხშირად შეუმჩნეველი რჩება**, მაგრამ ქვემდგომ სისტემებთან მიმართებაში მათი სწორად დაყენება კრიტიკულად მნიშვნელოვანია.  
_რამდენ ხანს უნდა ველოდო, სანამ ჩავთვლი, რომ ქვემდგომი სისტემა გამორთულია?_

თუ მეტისმეტად დიდხანს დაველოდებით, სანამ გადაწყვეტთ, რომ კავშირი ჩაიშალა, შეიძლება მთლიანი სისტემა დაამუხრუჭოთ. 

თუ ძალიან სწრაფად შეწყვეტთ ლოდინს, შეიძლება წარმატებული გამოძახება ტყუილად ჩაითვალოს წარუმატებლად.  
თუ საერთოდ არ გაქვთ timeout-ები, ქვემდგომი სისტემის გათიშვამ შესაძლოა მთელი სისტემა "გაყინოს".

 ყველა სისტემათშორისი (out-of-process) გამოძახება უნდა იყოს შემოსაზღვრული timeout-ით. 
 
დააწესეთ გონივრული ნაგულისხმევი (default) მნიშვნელობა და შემდგომ დააკვირდით, რა ხდება.  
ლოგირეთ timeout-ები, გააანალიზეთ შედეგები და საჭიროებისამებრ შეცვალეთ პარამეტრები.

---

### **Circuit Breaker-ები (ელექტრო გამშვები მექანიზმების ანალოგია)**

როგორც სახლის ელექტრო სისტემაში, **circuit breaker-ები იცავს მოწყობილობებს** ძაბვის ნახტომებისგან.  
თუ ნახტომი ხდება, ამოქმედდება გამშვები მექანიზმი, რაც იცავს ძვირადღირებულ ტექნიკას დაზიანებისგან.  
ასევე, შეგიძლიათ breaker-ი ხელითაც გამორთოთ, რომ უსაფრთხოდ იმუშაოთ.

Michael Nygard-ის წიგნი _Release It!_ აჩვენებს, როგორ შეიძლება ეს იდეა პროგრამულ უსაფრთხოებად გარდავაქციოთ.

---

წარმოიდგინეთ წინა მაგალითი ქვემდგომი რეკლამის სერვისი რეაგირებდა ძალიან ნელა და ბოლოს მაინც აძლევდა შეცდომას.  
მაშინაც კი, თუ timeout-ები სწორად გვქონდა დაყენებული, პასუხს დიდხანს ველოდებოდით.  
შემდეგ კვლავ იგივეს ვცდიდით და ისევ ველოდებოდით.  
ცუდია, რომ ქვემდგომი სერვისი არ მუშაობს, მაგრამ **ის ჩვენც გვანელებს**.

 **Circuit breaker-ის მეშვეობით**, გარკვეული რაოდენობის წარუმატებელი გამოძახების შემდეგ ის „იფეთქებს“.  
ამის შემდეგ ყველა მომდევნო გამოძახება მარცხდება სწრაფად — აღარ ცდილობს ლოდინს.  
დროის გასვლის შემდეგ, გარკვეული რაოდენობის საცდელი გამოძახება იგზავნება, რომ შევამოწმოთ, აღდგა თუ არა სერვისი.  
თუ საკმარისი ჯანსაღი პასუხი მიიღება, breaker-ი „გადატვირთავს თავს“.

---

**Circuit breaker-ის იმპლემენტაცია დამოკიდებულია იმაზე, რას ჩავთვლით წარუმატებელ გამოძახებად.**  
HTTP კონტექსტში, failure შეიძლება ნიშნავდეს timeout-ს ან 5XX კოდებს.  
ამ გზით, თუ ქვემდგომი რესურსი ან გათიშულია, ან აძლევს შეცდომებს, გარკვეული ზღვრის მიღწევის შემდეგ გამოვჭრით მასთან კავშირს  და სწრაფად ჩავაგდებთ მოთხოვნებს.  
როდესაც ყველაფერი ისევ წესრიგში იქნება, გამოვაცოცხლებთ კავშირს ავტომატურად.

---

 სწორად დაყენება რთული შეიძლება იყოს:

- არ გინდათ breaker-ი ჩაერთოს ზედმეტად ადრიანად
    
- მაგრამ არც ის გსურთ, ძალიან გვიან მოხდეს ეს
    

გამოიყენეთ ნაგულისხმევი პარამეტრები სისტემურად, და საჭიროების შემთხვევაში მოარგეთ კონკრეტულ შემთხვევებს.

---

**Circuit breaker-ის ამოქმედებისას რამდენიმე ვარიანტი გაქვთ:**

- შეგიძლიათ მოთხოვნები რიგში დააყენოთ და მოგვიანებით გაარესტარტოთ (ასინქრონულ ამოცანებში).
    
- მაგრამ თუ ეს არის სინქრონული გამოძახება, უმჯობესია **დავაიგნოროთ შეცდომა და სწრაფად ჩავაგდოთ**.
    
    - ეს შეიძლება იყოს შეცდომის გადაცემა ზემოთ,
        
    - ან ფუნქციონალის რბილი დეგრადაცია.
        

თუ ეს მექანიზმი გვაქვს გამოყენებული, შეგვიძლია მანუალური breaker-ის აფეთქება ტექნიკური სამუშაოებისას 
მაგალითად, თუ მიკროსერვისი დროებით უნდა გავთიშოთ, ხელით „გავაფეთქებთ“ მასზე დამოკიდებული სერვისების breaker-ებს.  
შედეგად, ისინი მარცხდებიან სწრაფად და არ ელოდებიან.  
მოგვიანებით, როცა სერვისი აღდგება, breaker-ებიც ავტომატურად ან ხელით „დავაბრუნებთ“ და ყველაფერი ნორმალურად განახლდება.

![[Pasted image 20250919233614.png]]
##### ფიგურა 11-2 Circuit breaker-ების მიმოხილვა


---

### Bulkheads

კიდევ ერთ პატერნში, წიგნიდან _Release It!_ ნიგარდი შემოაქვს bulkhead-ის კონცეფცია, როგორც გზა, რომლითაც შეძლებ იზოლირდე გაუმართაობისგან. გემზე bulkhead არის ნაწილი, რომელსაც შეიძლება დაედგას ჰერმეტული კარები, რათა დაიცვას გემის დანარჩენი ნაწილი. ასე რომ, თუ გემში გაჩნდა გაჟონვა, შეგიძლია დახურო bulkhead-ის კარები. გემის ნაწილი დაიკარგება, მაგრამ დანარჩენი დარჩება უვნებელი.

სოფტვეარ არქიტექტურის თვალსაზრისით, მრავალი სხვადასხვა bulkhead შეიძლება განვიხილოთ. ჩემი საკუთარი გამოცდილების დაბრუნებით, ჩვენ რეალურად გამოვტოვეთ bulkhead-ის დანერგვის შესაძლებლობა. თითოეული downstream კავშირისათვის უნდა გგვქონოდა განსხვავებული connection pool-ები. ასე, თუ ერთი connection pool ამოიწურებოდა, სხვა კავშირებზე ეს არ იმოქმედებდა, როგორც ნაჩვენებია ფიგურაში 11-3. ეს უზრუნველყოფდა, რომ თუ downstream სერვისი მომავალში ნელა დაიწყებდა მუშაობას, მხოლოდ ის ერთი connection pool დაზარალდებოდა და სხვა ზარები ჩვეულებრივად გაგრძელდებოდა.
![[Pasted image 20250919233858.png]]
ფიგურა 11-3. თითოეული downstream სერვისისთვის connection pool-ის გამოყენება bulkhead-ის უზრუნველსაყოფად

ფუნქციონალის განცალკევებაც შეიძლება იყოს bulkhead-ის განხორციელების გზა. ფუნქციონალის გამოყოფით ცალკე მიკროსერვისებად, ვამცირებთ შანსს, რომ ერთ სფეროში ავარიამ სხვა სფეროზე მოახდინოს გავლენა.

შეხედე სისტემის ყველა იმ ასპექტს, რაც შეიძლება გაუფუჭდეს — როგორც მიკროსერვისების შიგნით, ასევე მათ შორის. გაქვს თუ არა bulkhead-ები დანერგილი? მე ვთავაზობ, რომ დაიწყოთ მინიმუმ თითოეული downstream კავშირისათვის ცალკე connection pool-ებით. თუმცა შეიძლება კიდევ უფრო შორს წახვიდე და circuit breaker-ებიც განიხილო.

ჩვენ შეგვიძლია ვიფიქროთ circuit breaker-ებზე როგორც ავტომატურ მექანიზმზე bulkhead-ის დასალუქად, რათა არა მხოლოდ დაიცვას consumer downstream პრობლემისგან, არამედ, შესაძლოა, დაიცვას downstream სერვისიც ზედმეტი ზარებისგან, რომლებიც უარყოფით გავლენას ახდენენ. გადამდები მარცხის საფრთხის გათვალისწინებით, ვგირჩევ, ყველა სინქრონული downstream ზარისათვის სავალდებულოდ დანერგო circuit breaker-ები. თანაც საკუთარი წერის საჭიროება არაა — Netflix-ის Hystrix ბიბლიოთეკა JVM circuit breaker-ის აბსტრაქციაა, რომელიც ძლიერი მონიტორინგით მოდის, მაგრამ არსებობს სხვა იმპლემენტაციებიც სხვადასხვა ტექნოლოგიური სტეკებისთვის, როგორიცაა Polly .NET-სთვის, ან circuit_breaker mixin Ruby-სთვის.

ბევრ თვალსაზრისში, bulkhead-ები ამ სამი პატერნიდან ყველაზე მნიშვნელოვანია. Timeouts და circuit breaker-ები გეხმარება რესურსების გათავისუფლებაში მაშინ, როცა ისინი შეზღუდულია, მაგრამ bulkhead-ები უზრუნველყოფს, რომ ეს შეზღუდვა საერთოდ არ მოხდეს. Hystrix, მაგალითად, გაძლევს საშუალებას დანერგო bulkhead-ები, რომლებიც გარკვეულ პირობებში პირდაპირ უარყოფენ მოთხოვნებს, რათა რესურსები კიდევ უფრო არ გადაიტვირთოს; ეს ცნობილია როგორც load shedding. ზოგჯერ მოთხოვნის უარყოფა საუკეთესო გზაა მნიშვნელოვანი სისტემის გადატვირთვისა და მრავალი upstream სერვისისთვის ბოთლნეკად ქცევის თავიდან ასაცილებლად.

---

### Isolation  
რაც უფრო მეტად არის ერთი სერვისი დამოკიდებული მეორის მუშაობაზე, მით უფრო მოქმედებს ერთის ჯანმრთელობა მეორის შესაძლებლობაზე, შეასრულოს თავისი საქმე. თუ გამოვიყენებთ ინტეგრაციის ტექნიკებს, რომლებიც downstream სერვერს საშუალებას აძლევს იყოს ოფლაინში, upstream სერვისებს ნაკლები შანსი ექნებათ დაზარალდნენ გათიშვებისგან, დაგეგმილი თუ დაუგეგმავი.

არსებობს კიდევ ერთი სარგებელი სერვისებს შორის იზოლაციის გაზრდისას. როდესაც სერვისები ერთმანეთისგან იზოლირებულია, ბევრად ნაკლები კოორდინაციაა საჭირო სერვისების მფლობელებს შორის. რაც ნაკლები კოორდინაციაა საჭირო გუნდებს შორის, მით მეტი ავტონომია აქვთ ამ გუნდებს, რადგან მათ შეუძლიათ იმუშაონ და განავითარონ თავიანთი სერვისები უფრო თავისუფლად.